// merge.ts
// generated by polka.codes

import { Glob } from "bun";

// Defines the structure of a finding object based on the JSON schema.
interface Finding {
  id: string;
  title: string;
  severity: string;
  component: string;
  description: string;
  impact: string;
  kind: string;
  report?: string;
  [key: string]: any; // Allow for other properties that are not strictly defined.
}

/**
 * Escapes a string for use in a CSV file.
 * If the string contains a comma, newline, or double quote, it will be enclosed in double quotes.
 * Existing double quotes will be escaped by doubling them.
 * @param field The string to escape.
 * @returns The escaped string.
 */
const escapeCsvField = (field: any): string => {
  if (field === null || field === undefined) {
    return "";
  }
  const str = String(field);
  // Regex to check if escaping is needed
  if (/[",\n\r]/.test(str)) {
    return `"${str.replace(/"/g, '\'\'\"\"\'\'')}"`;
  }
  return str;
};

/**
 * Main function to find, merge, and convert JSON findings to a CSV file.
 */
async function main() {
  // Using Bun's Glob API for efficient file searching.
  const glob = new Glob("**/*.json");
  const allFindings: Finding[] = [];

  console.log("Starting to search for JSON files...");

  // Scan the current directory and its subdirectories.
  for await (const file of glob.scan(".")) {
    // We want to avoid processing files that are not audit reports.
    if (file.includes("node_modules") || file.includes("package.json") || file.includes("tsconfig.json") || file.includes("bun.lockb")) {
        continue;
    }

    try {
      const fileContent = await Bun.file(file).text();
      if (!fileContent.trim()) {
        console.warn(`Skipping empty file: ${file}`);
        continue;
      }

      const findings = JSON.parse(fileContent);

      // Ensure the parsed content is an array before processing.
      if (Array.isArray(findings)) {
        if (findings.length > 0 && findings[0].id && findings[0].title) {
            const findingsWithReport = findings.map(finding => ({ ...finding, report: file }));
            console.log(`Found ${findingsWithReport.length} findings in ${file}`);
            allFindings.push(...findingsWithReport);
        } else if (findings.length === 0) {
            console.log(`File ${file} contains an empty array.`);
        } else {
            console.warn(`Skipping ${file}: does not appear to contain valid findings.`);
        }
      } else {
        console.warn(`Skipping ${file}: content is not a JSON array.`);
      }
    } catch (error) {
      // Catch JSON parsing errors or other file reading issues.
      console.error(`Error processing file ${file}:`, error instanceof Error ? error.message : String(error));
    }
  }

  if (allFindings.length === 0) {
    console.log("No findings were found across all JSON files. Exiting.");
    return;
  }

  console.log(`Total findings collected: ${allFindings.length}.`);
  console.log("Generating CSV file...");

  // Define the headers for the CSV file.
  const headers = [
    "id",
    "title",
    "severity",
    "component",
    "description",
    "impact",
    "kind",
    "report",
  ];

  // Convert findings to CSV format.
  const csvRows = allFindings.map(finding =>
    headers.map(header => escapeCsvField(finding[header])).join(",")
  );

  // Prepend header row.
  const csvContent = [headers.join(","), ...csvRows].join("\n");

  // Write the CSV content to results.csv.
  await Bun.write("results.csv", csvContent);

  console.log("Successfully created results.csv");
}

// Execute the main function and catch any top-level errors.
main().catch(err => {
    console.error("An unexpected error occurred:", err);
});

id,title,severity,component,description,impact,kind,report
S1-2135,Minimum staking amount not enforced,Low,Frequency-capacity-pallet,"The `ensure_can_stake` function is intended to verify that a staking amount exceeds the required minimum. However, it checks the sum of the user's current active stake and the new stake amount, rather than the new amount in isolation. This allows a user to make a valid initial stake and then make subsequent stakes of as little as 1 token, bypassing the intended economic constraint.","An attacker can underpay for storage usage by making many small staking requests after an initial valid one, leading to potential storage bloating and slowing down the network.",Implementation,2024 H2/2409-frequency-srl/frequency-srl-2409.json
S1-2147,Possible user handle confusion,Low,Frequency-handles-pallet,"When a user claims a handle, the system checks against a list of reserved words like 'admin'. This check does not account for the canonical representation of Unicode characters, allowing a user to register a handle with characters that are visually confusable with a reserved name (e.g., using a homoglyph for 'a').","A user could claim a handle that closely resembles a reserved or official handle, potentially misleading other users into believing they hold a special or privileged status.",Input Validation,2024 H2/2409-frequency-srl/frequency-srl-2409.json
SO-2134,Possible interoperability issue in passkey signature verification,Informational,Frequency-pallet-passkey,"The `check_account_signature` function expects signature data to be wrapped in `<Byte>` tags, following a convention used by the polkadot-js-extension. If a third-party application submits a raw signature without this specific wrapping, the signature verification will fail, resulting in transaction errors.","This requirement can cause interoperability problems with third-party applications that are unaware of or do not implement this specific data wrapping convention, limiting broader ecosystem compatibility.",Design,2024 H2/2409-frequency-srl/frequency-srl-2409.json
S1-52,Failed assumption: new_xcm_location for foreign asset may already exist,Low,/pallets/moonbeam-foreign-assets/src/lib.rs,"The function to create a new foreign asset ensures its XCM location does not already exist. However, a separate governance function to change an asset's XCM location ('change_xcm_location') fails to perform the same check, making it possible to assign a location that is already in use.","A malicious or accidental governance action could configure multiple foreign assets to use the same XCM location. This would cause collisions in asset resolution, leading to confusion and undefined behavior.",Implementation,2024 H2/2411-moonbeam-srl/moonbeam-srl-2411.json
insufficient-iteration-limit-in-hash-point-decompression--combinatorial-tokens--high,Insufficient iteration limit in hash point decompression,High,combinatorial-tokens,"Hash point decompression is limited to 32 iterations, while mathematical evidence suggests approximately 507 iterations might be required to find a valid point on the alt_bn128 curve. This discrepancy means the decompress_hash function may frequently fail to find a valid y-coordinate, even for valid inputs.","This can result in a systemic failure of collection ID generation, effectively causing a denial of service in the combinatorial tokens system.",Implementation,2024 H2/2410-zeitgeist-oak/zeitgeist-oak-2410.json
incorrect-logarithm-calculation--neo-swaps--high,Incorrect logarithm calculation,High,neo-swaps,"The log_ceil implementation for u16 uses an incorrect value to determine the number of bits, leading to a faulty logarithm calculation for all values. This math utility is used for weight computation in several key functions.",The incorrect weight calculation leads to disproportionate overcharging of users for computation costs.,Implementation,2024 H2/2410-zeitgeist-oak/zeitgeist-oak-2410.json
low-account-costs-could-facilitate-the-exhaustion-of-parachain-resources--runtime--high,Low account costs could facilitate the exhaustion of parachain resources,High,runtime,"The ExistentialDeposit, the cost to keep an account active, is defined as 5 MILLI ZGT, which corresponds to a very low fiat value. This low cost could allow an attacker to bloat the parachain's storage with a large number of active accounts for a minimal cost.","The costs of maintaining the bloated data might exceed the initial creation costs, leading to potential Denial-of-Service scenarios.",Configuration,2024 H2/2410-zeitgeist-oak/zeitgeist-oak-2410.json
oracle-price-comparison-is-prone-to-manipulation--neo-swaps--medium,Oracle price comparison is prone to manipulation,Medium,neo-swaps,"The try_evaluate function determines outcomes by directly comparing spot prices between positive and negative outcomes. This approach lacks safeguards, such as using a time-weighted average price, making the oracle vulnerable to price manipulation and MEV attacks.","Malicious actors could manipulate prices to influence outcomes, although the report notes the impact is limited because the creation of decision markets is permissioned.",Design,2024 H2/2410-zeitgeist-oak/zeitgeist-oak-2410.json
unverified-proposal-oracle-could-facilitate-approval-of-malicious-proposal--futarchy--medium,Unverified proposal oracle could facilitate approval of malicious proposal,Medium,futarchy,The maybe_schedule_proposal function checks a proposal's approval by calling an oracle that is part of the proposal structure itself. This oracle is not verified when the proposal is submitted or scheduled.,A malicious oracle could be specified to arbitrarily approve or reject a proposal. The report notes this could have major consequences if permissionless proposal creation is implemented.,Access Control,2024 H2/2410-zeitgeist-oak/zeitgeist-oak-2410.json
overflow-checks-are-not-enabled-for-the-release-profile--unspecified--medium,Overflow checks are not enabled for the release profile,Medium,unspecified,"The crates in scope do not enable the overflow-checks flag for the release build profile. Since Rust does not enforce overflow checks by default in release mode, this could lead to unexpected behavior if arithmetic operations overflow.","Integer overflows or underflows may occur silently, leading to unintended consequences, especially if checked math operations are not used consistently throughout the codebase.",Configuration,2024 H2/2410-zeitgeist-oak/zeitgeist-oak-2410.json
faulty-test-case-introduces-maintenance-risk--combinatorial-tokens--medium,Faulty test case introduces maintenance risk,Medium,combinatorial-tokens,"In the test suite for redeeming positions, the test cases 'all_zero' and 'all_one' use identical input vectors. This duplication means the scenario for 'all_one' is not actually being tested, which could hide potential bugs.","Incorrect test cases can lead to maintenance issues and reduced confidence in the test suite's effectiveness, potentially allowing bugs in untested code paths to go unnoticed.",Process,2024 H2/2410-zeitgeist-oak/zeitgeist-oak-2410.json
unresolved-fixme-comments-in-the-codebase--unspecified--informational,Unresolved FIXME comments in the codebase,Informational,unspecified,"The audit identified several unresolved FIXME comments in the codebase, specifically within the combinatorial-tokens and neo-swaps pallets. These comments indicate areas that require further attention or revision.","FIXME comments may point to code that is incomplete, suboptimal, or incorrect, creating technical debt and increasing maintenance overhead.",Documentation,2024 H2/2410-zeitgeist-oak/zeitgeist-oak-2410.json
the-project-has-dependencies-on-vulnerable-crates--unspecified--informational,The project has dependencies on vulnerable crates,Informational,unspecified,"The project depends on versions of 'curve25519-dalek' and 'rustls' that are affected by known security advisories (RUSTSEC-2024-0344 and RUSTSEC-2024-0336, respectively).","The identified vulnerabilities in the dependencies could potentially be exploited, posing a security risk to the project.",Dependency,2024 H2/2410-zeitgeist-oak/zeitgeist-oak-2410.json
unresolved-todo-comments-in-the-codebase--unspecified--informational,Unresolved TODO comments in the codebase,Informational,unspecified,"The audit identified numerous unresolved TODO comments scattered throughout the codebase. These comments signify planned enhancements, missing features, or areas needing further work.","A large number of TODO comments can indicate an incomplete codebase, creating technical debt and making the code harder to maintain and understand.",Documentation,2024 H2/2410-zeitgeist-oak/zeitgeist-oak-2410.json
HI-01,Unrestricted URI,High,pallets/laos-evolution,"If a collection created via the EvolutionCollectionFactory precompile is configured to allow public minting, any user can create new collection items pointing to arbitrary malicious URIs. This is possible for any unused slot within the collection.","Malicious URIs could direct users to browser exploits, client-side attacks, or illegal content. These URIs would be associated with the NFT collection and displayed on platforms where the NFTs are traded.",Access Control,2024 H2/2407-laos-coinfabrik/coinfabrik-laos-2407.json
ME-01,Lack of URI Validation,Medium,"pallets/asset-metadata-extender, pallets/laos-evolution",URIs received by the AssetMetadataExtender and EvolutionCollection precompiles are not validated for correct format or canonized before being stored on-chain. This allows for malformed URIs to be written into the blockchain's state.,Other systems that read URI data from the blockchain could be vulnerable to exploits that leverage malformed URIs. This issue increases the risk of the 'HI-01 Unrestricted URI' finding.,Input Validation,2024 H2/2407-laos-coinfabrik/coinfabrik-laos-2407.json
MI-01,No Logging on Minting Error,Low,pallets/parachain-staking/src/rewards/mint_rewards.rs,"When new blocks are created, if the system fails to deposit funds for the collator's reward, the error is not logged or registered. The code handles the success case but has no 'else' clause for the failure case.","A failure to reward a collator would happen silently, making it difficult to detect or debug potential issues with the reward mechanism. This could lead to collators not being paid without any notification.",Implementation,2024 H2/2407-laos-coinfabrik/coinfabrik-laos-2407.json
MI-02,Lack of Universal Location Validation,Low,pallets/asset-metadata-extender,The functions `extendULWithExternalURI` and `updateExtendedULWithExternalURI` do not validate the universal location string parameter. This unvalidated string is then reflected in emitted events that can be processed by other systems.,Systems that consume and process emitted events could be exploited by malformed universal location strings. The risk is lower than state corruption as it is confined to event data.,Input Validation,2024 H2/2407-laos-coinfabrik/coinfabrik-laos-2407.json
H-01,TransferFrom is incorrectly treated as a view function,High,MultiCurrencyPrecompile,"In the `MultiCurrencyPrecompile` module, the `check_function_modifier` fails to handle the `Function::TransferFrom` case, causing it to default to being a view function. This is incorrect as `TransferFrom` is a state-changing operation.","This misclassification can lead to unexpected failures when `TransferFrom` is invoked in contexts that restrict state changes, as the execution environment will incorrectly treat it as a read-only call.",Implementation,2024 H2/2410-hydration-pashov/hydration-pashov-2410.json
M-01,Unbounded storage iteration in EVM address registration migration,Medium,SetCodeForErc20Precompile,The `on_runtime_upgrade` function performs an unbounded iteration over all assets in the registry to register their EVM addresses. This process occurs within a single transaction.,"If the number of assets is large, the migration could exceed block weight limits, causing the runtime upgrade to fail and potentially leading to network downtime.",Design,2024 H2/2410-hydration-pashov/hydration-pashov-2410.json
M-02,Failure to verify ERC20 function return values in handle_result(),Medium,Erc20Currency,"The `handle_result` function, which processes ERC20 contract calls, only checks the EVM `exit_reason` for success. It does not validate the returned data, which for many ERC20 tokens is a boolean `false` indicating failure.","The system may incorrectly assume an ERC20 operation was successful when it failed, leading to inconsistencies between the application's state and the actual token contract state.",Implementation,2024 H2/2410-hydration-pashov/hydration-pashov-2410.json
M-03,Unbounded memory growth via EVM Error message allocations,Medium,executor.rs,"The EVM error handling mechanism in `executor.rs` uses `Box::leak` to create permanent memory allocations for each unique error value. Since error messages include dynamic data, an attacker can generate a large number of unique errors.","This can lead to unbounded memory growth across all network nodes, which cannot be reclaimed without a restart, creating a potential Denial of Service (DoS) vector.",Implementation,2024 H2/2410-hydration-pashov/hydration-pashov-2410.json
L-01,EIP-2 signature malleability in Permit validation,Low,permit.rs,"The `validate_permit` function does not validate that the `s` value of the ECDSA signature is in the lower half of the curve order, as required by EIP-2. This allows for signature malleability, where multiple valid signatures can exist for the same message.","This deviation from a widely-adopted standard could lead to compatibility issues or be a contributing factor in more complex exploits, even if it does not pose a direct, immediate risk.",Cryptography,2024 H2/2410-hydration-pashov/hydration-pashov-2410.json
L-02,Missing logging in runtime upgrade implementation,Low,SetCodeForErc20Precompile,"The `on_runtime_upgrade` function for the ERC20 precompile lacks any logging mechanisms to track its progress or results. This makes it difficult to monitor the upgrade, debug failures, or audit the changes post-deployment.","The absence of logging complicates operational monitoring and incident response, making it harder to verify that the upgrade completed successfully or to diagnose the cause of any failures.",Operational,2024 H2/2410-hydration-pashov/hydration-pashov-2410.json
L-03,EVM exit status misclassification in handle_result(),Low,handle_result(),The `handle_result` function incorrectly classifies the `ExitSucceed::Suicided` EVM exit status as an error. This status is the correct and expected outcome for a successful `SELFDESTRUCT` operation.,"Valid contract self-destruct operations will be incorrectly marked as failed transactions, which diverges from standard EVM behavior and could break applications that rely on this functionality.",Implementation,2024 H2/2410-hydration-pashov/hydration-pashov-2410.json
L-04,Oversized EVM error messages due to full value encoding,Low,erc20_currency.rs,"The `handle_result` function encodes the entire return `value` from a failed EVM call into the resulting error message. For operations that can return large amounts of data, this leads to oversized error messages.",Large error messages can cause excessive memory allocation and lead to unnecessary storage bloat if they are logged on-chain or stored in network history.,Implementation,2024 H2/2410-hydration-pashov/hydration-pashov-2410.json
L-05,Unchecked message size in call(),Low,executor,The executor's `call` function accepts input `data` of any size without validation. There is no check to limit the size of the message being passed to a contract for execution.,Allowing arbitrarily large messages to be processed can lead to excessive gas consumption and potential Denial of Service (DoS) attacks by forcing the system to handle oversized inputs.,Input Validation,2024 H2/2410-hydration-pashov/hydration-pashov-2410.json
S3-43,ExistentialDeposit is configured to 0,High,runtime,"The ExistentialDeposit parameter, which is designed to facilitate the automatic removal of inactive accounts, is set to zero in the Peaq runtime. This configuration disables the cleanup mechanism, causing account data to be permanently stored on-chain even if the account has no balance.","This allows for storage spamming attacks where an attacker can cheaply create a vast number of accounts, leading to blockchain bloat, degraded node performance, and increased operational overhead.",Configuration,2024 H2/2409-peaq-srl/peaq-srl-2409.json
S3-40,Incorrectly on_finalize weights might lead to denial-of-service attacks,High,pallets/parachains-staking,"The `on_initialize` hook uses a static weight for its calculations, failing to dynamically simulate the actual weight that will be consumed by the `on_finalize` hook later. This leads to an underestimation of the computational resources required for block finalization.","The miscalculation of weights increases the risk of producing overweight blocks. Such blocks may be rejected by the network, leading to service disruptions and an inability to finalize transactions.",Implementation,2024 H2/2409-peaq-srl/peaq-srl-2409.json
S3-39,Collator can drain delegator's rewards by manipulation commission rate,High,pallets/parachains-staking,"A collator can change their commission rate at any time without restriction. A malicious collator can attract delegators by advertising a low commission rate and then, after securing delegations, raise the rate to 100% to divert all staking rewards to themselves.","Delegators are exposed to significant financial loss, as their rewards can be redirected entirely without their consent. This undermines trust in the staking system and discourages network participation.",Design,2024 H2/2409-peaq-srl/peaq-srl-2409.json
S3-36,Missing trait-in-use checks in _validateTraitOwnership enables infinite minting,High,contracts/SolarSeekers.sol,"The minting process lacks a mechanism to verify whether a specific base trait has already been used to create a derived token. The `_validateTraitOwnership` function confirms ownership but does not track trait usage, permitting the same traits to be reused indefinitely.","This allows for the unlimited minting of derived tokens from a finite set of base traits, which devalues the entire NFT collection. The resulting inflation erodes user trust and causes financial losses for holders.",Access Control,2024 H2/2409-peaq-srl/peaq-srl-2409.json
S2-37,Single trait approval for NFT minting limits usability and efficiency,Medium,contracts/SolarSeekerTraits.sol,"The current approval mechanism only permits a user to have one approved trait at a time. Since minting a final NFT requires at least four traits, users must engage in a repetitive and cumbersome cycle of requesting approval and minting for each individual trait.","This design leads to a poor user experience, increases the likelihood of errors from overwritten approvals, and results in higher gas costs due to the necessity of multiple transactions.",Design,2024 H2/2409-peaq-srl/peaq-srl-2409.json
S2-35,Trait token may be reused to satisfy multiple trait slots,Medium,contracts/SolarSeekers.sol,"The system fails to enforce the uniqueness of traits used in the minting process, allowing a user to reuse the same trait token to fill multiple slots. This allows a derived NFT to be minted with only a single valid trait instead of the required four distinct ones.","This issue undermines the non-fungibility of the derived tokens and misleads users about their uniqueness. It breaks the intended supply bounding of derived minting, potentially devaluing the assets.",Implementation,2024 H2/2409-peaq-srl/peaq-srl-2409.json
S2-18,Permissive `GasLimitStorageGrowthRatio` leads to excessive storage growth,Medium,runtime,The `GasLimitStorageGrowthRatio` is configured to a 1-to-1 ratio between gas consumption and storage growth. This setting makes on-chain storage disproportionately cheap compared to the computational cost.,"This configuration creates a risk of cheap storage bloating, where an attacker could flood the blockchain with storage-heavy transactions at a low cost, severely affecting network scalability and maintainability.",Configuration,2024 H2/2409-peaq-srl/peaq-srl-2409.json
S2-16,Incorrect benchmarks for `pallet_evm`,Medium,runtime,The `pallet_evm` uses default Substrate benchmarks instead of benchmarks tailored to the specific Peaq runtime configuration. Default benchmarks do not accurately reflect the resource usage of EVM-related extrinsics on Peaq.,"Relying on default benchmarks leads to inaccurate weight calculations for transactions. This can result in underweight extrinsics, which pose a security risk by allowing transactions to consume more resources than allocated, potentially destabilizing the network.",Configuration,2024 H2/2409-peaq-srl/peaq-srl-2409.json
S1-42,Unsafe arithmetic can halt collator payouts,Low,pallets/parachains-staking,"The `get_collator_reward_per_session` function uses an arithmetic operation that is vulnerable to an overflow. If the total delegated stake exceeds the `u128::MAX` limit, the sum resets to zero, causing the reward calculation to incorrectly yield zero rewards for the collator.","In the unlikely event of an overflow, collators would not receive their due rewards, which could undermine their incentive to secure the network. This poses a low risk to the network's economic stability.",Implementation,2024 H2/2409-peaq-srl/peaq-srl-2409.json
S1-41,Lack of weight tracking in note_author() hook,Low,pallets/parachain_staking,"The `note_author()` hook, which tracks collator selection, performs state changes without tracking the associated computational weight. The resources consumed by its read and write operations are not reported to the runtime.","While the current weight is minimal, this is poor practice. If the function's complexity grows, the untracked weight could contribute to the creation of overweight blocks, potentially causing chain stalls.",Implementation,2024 H2/2409-peaq-srl/peaq-srl-2409.json
S1-32,Missing sanity checks for traitContract address,Low,contracts/SolarSeekers.sol,"The `traitContract` address is initialized during deployment without validation to ensure it is not a null or incorrect address. If a misconfiguration occurs, there is no in-contract mechanism to update the address post-deployment.","An incorrect `traitContract` address would render the primary `mintWithTraits` function unusable, breaking core contract functionality. The only remedy would be a costly and disruptive redeployment of the contract.",Implementation,2024 H2/2409-peaq-srl/peaq-srl-2409.json
S1-31,Single-step ownership transferal,Low,contracts,"The contracts utilize a single-step ownership transfer mechanism, where ownership is immediately transferred to a new address upon the owner's request. This process lacks a confirmation step from the recipient to verify their ability and intent to assume ownership.",Transferring ownership to a mistyped address or a contract that cannot manage ownership roles would result in a permanent loss of control. This could necessitate a full redeployment of the contract.,Access Control,2024 H2/2409-peaq-srl/peaq-srl-2409.json
S1-15,Incorrect topic selector for `RemoveAttribute` event submission,Low,precompiles,A typographical error in the `RemoveAttribute` function signature (`RemoveAttribte`) causes an incorrect event topic to be generated when the function is executed. This inconsistency affects systems that listen for this specific event.,Off-chain monitoring tools and other systems relying on event detection will fail to capture these events. This can lead to incomplete data and malfunctioning event-driven workflows.,Implementation,2024 H2/2409-peaq-srl/peaq-srl-2409.json
S0-38,Gas optimizations and logic efficiency,Informational,contracts,"The audit identified several opportunities for gas optimization. Recommendations include using custom errors over require strings, preferring prefix (++i) over postfix (i++) increments in loops, caching storage items in memory for complex operations, and setting function visibility to `external` where appropriate.",These optimizations do not address a direct vulnerability but would lead to reduced transaction fees for users and lower execution overhead for the network.,Implementation,2024 H2/2409-peaq-srl/peaq-srl-2409.json
S0-33,Missing events in SolarSeekers and SolarSeekersTraits contracts,Informational,contracts/SolarSeekers.sol,"Key functions that alter the contract's state, such as `updateTraits()` and `allowMint()`, do not emit events upon execution. The absence of event logging for these critical actions makes it difficult for off-chain applications to monitor and react to state changes.","The lack of events limits the capabilities of monitoring and tracing tools, potentially leading to an inaccurate or incomplete understanding of the system's state by external services.",Implementation,2024 H2/2409-peaq-srl/peaq-srl-2409.json
S0-19,Missing size checkings could lead to unnecessary gas cost,Informational,precompiles/peaq-rbac,"The `add_permission` precompile does not validate the size of input parameters before dispatching the call. If an input exceeds the maximum allowed size, the transaction is reverted, but only after consuming gas that could have been saved with an initial size check.","While not a security risk, this issue can lead to users paying for transactions that are destined to fail, resulting in unnecessary gas costs and a suboptimal user experience.",Input Validation,2024 H2/2409-peaq-srl/peaq-srl-2409.json
S0-17,Incorrect fields names in reverted function backtraces,Informational,precompiles,"When precompile calls fail, the logged backtraces use generic or misleading parameter names (e.g., `amount` instead of `value`). This makes troubleshooting and long-term maintenance of the codebase more cumbersome.","This issue does not pose a security risk but can cause confusion for developers and users trying to diagnose why a specific call was reverted, thereby increasing debugging time.",Documentation,2024 H2/2409-peaq-srl/peaq-srl-2409.json
HO-2503-01,Potential denial of service by storing non-whitelisted pairs from Bifrost oracle,High,pallets/ema-oracle,"Data from the Bifrost source is accepted and stored in the Accumulator even if the pair is not whitelisted. If Bifrost continuously pushes updates for non-whitelisted pairs, they consume the MaxUniqueEntries capacity, preventing valid (whitelisted) entries from being recorded, effectively cluttering the pallet with irrelevant data.","This can lead to a denial of service scenario where legitimate updates are locked out because the pallet's capacity is consumed by non-whitelisted, irrelevant data.",Input Validation,2025 Q1/hydration-oak-2503/hydration-oak-2503.json
HO-2503-02,Liquidity providers can be blocked from exit,High,pallets/stableswap,The `remove_liquidity_one_asset` function validates that either a provider performs a full exit or that the remaining liquidity is above `MinPoolLiquidity`. This logic creates scenarios where a liquidity provider who wishes to exit fully cannot do so if another provider's partial withdrawal leaves the pool liquidity just above the minimum threshold.,"A liquidity provider can be prevented from withdrawing their entire stake, effectively locking their funds in the pool until another user adds more liquidity.",Implementation,2025 Q1/hydration-oak-2503/hydration-oak-2503.json
HO-2503-03,Liquidity of any asset can be inflated or deflated by the registry owner,High,pallets/stableswap,"The `do_add_liquidity` function does not use the `normalize_value` function when adding new liquidity to a reserve. If the registry owner updates the decimals of a registered asset, all existing liquidity pools with that asset become corrupted, as the stored values are not adjusted for the new precision.","A malicious or mistaken registry owner can arbitrarily inflate or deflate the value of assets in liquidity pools, leading to significant financial loss for liquidity providers.",Implementation,2025 Q1/hydration-oak-2503/hydration-oak-2503.json
HO-2503-04,Unexpected behavior results from inability to remove oracle data set during genesis,Medium,pallets/ema-oracle,"Genesis oracle entries are stored in the pallet's storage without being added to the `WhitelistedAssets` variable. The `remove_oracle` extrinsic requires an asset to be whitelisted for removal, making it impossible to remove genesis-defined oracles if support for them is later discontinued.","The pallet accumulates unnecessary and outdated oracle data, which can lead to unintended oracle usage within the stableswap pallet.",Configuration,2025 Q1/hydration-oak-2503/hydration-oak-2503.json
HO-2503-05,Missing slippage protection in add_liquidity extrinsic,Medium,pallets/stableswap,"The `add_liquidity` function does not implement slippage protection, unlike other liquidity-related functions in the pallet. This is also inconsistent with Curve Finance's implementation, which includes a `min_mint_amount` parameter to protect users.","Users adding liquidity may receive significantly fewer shares than expected due to front-running attacks or market volatility, potentially resulting in financial losses.",Implementation,2025 Q1/hydration-oak-2503/hydration-oak-2503.json
HO-2503-06,Missing protection for rapid amplification changes,Medium,pallets/stableswap,"The `update_amplification` function lacks a minimum timeframe requirement between consecutive changes. This differs from Curve Finance, which enforces a one-day waiting period (`MIN_RAMP_TIME`) for such updates.","A malicious actor with privileged access could manipulate the amplification parameter in rapid succession, causing pool instability and creating arbitrage opportunities to extract value.",Access Control,2025 Q1/hydration-oak-2503/hydration-oak-2503.json
HO-2503-07,Pool destructure procedure is not complete,Medium,pallets/stableswap,"When a pool is destroyed via the `remove_liquidity` function, the corresponding peg data of type `PegInfo` is not removed from storage. This leaves stale entries in the `PoolPegs` storage map even though the pool is no longer active.","The system retains stale and orphaned data in its storage, which could lead to inconsistencies or unexpected behavior if other parts of the system assume that peg info corresponds to an active pool.",Implementation,2025 Q1/hydration-oak-2503/hydration-oak-2503.json
HO-2503-08,Silent duplication error handling during liquidity removal,Informational,pallets/stableswap,"The `remove_liquidity` function does not explicitly validate that asset IDs in `min_amounts_out` are unique. While it checks if the length matches the pool's asset count, a duplicate asset would cause a later failure with a generic `IncorrectAssets` error, obscuring the root cause.","Error handling is not precise, making debugging and off-chain error interpretation more difficult for developers and users.",Implementation,2025 Q1/hydration-oak-2503/hydration-oak-2503.json
HO-2503-09,Insufficient pool fee validation,Informational,pallets/stableswap,"The `update_pool_fee` function lacks important validations. It does not validate the new fee against a maximum allowed value, meaning a fee could be set to 100%, and it does not check if the new fee is different from the current one, allowing for redundant updates.","Without a fee ceiling, a malicious actor could set an extreme fee that breaks normal pool operations. Allowing redundant updates is inefficient.",Input Validation,2025 Q1/hydration-oak-2503/hydration-oak-2503.json
HO-2503-10,Missing staleness monitoring for oracle data,Informational,pallets/stableswap,"When fetching oracle data via `get_raw_entry`, the code does not verify whether the oracle feed is updating regularly. The pallet does not log any warnings if the oracle feed stops providing fresh data for an extended period.","The pallet may unknowingly rely on outdated price data, which could lead to incorrect pricing and financial decisions, especially if an oracle feed like Bifrost's ceases to operate.",Operational,2025 Q1/hydration-oak-2503/hydration-oak-2503.json
HO-2503-11,Potential for optimization in shares calculation,Informational,math/stableswap,"In the `calculate_shares` function, the call to `calculate_d` can be optimized for the specific case where `share_issuance` is zero. In this scenario, a result can be returned immediately without performing the more computationally expensive calculations that follow.","The code performs unnecessary computations in a specific, yet common, edge case, leading to minor gas inefficiencies.",Implementation,2025 Q1/hydration-oak-2503/hydration-oak-2503.json
HO-2503-12,Possible optimization in create_pool function,Informational,pallets/stableswap,"The `create_pool` function validates the length of the input `assets` vector against a maximum threshold, but it does so late in the function. An immediate validation at the start of the function would be more efficient.","The function may perform unnecessary operations before failing, leading to wasted execution time and gas in cases where the input asset vector is invalid.",Implementation,2025 Q1/hydration-oak-2503/hydration-oak-2503.json
HO-2503-13,Inconsistency in update_amplification specification,Informational,pallets/stableswap,The documentation comments for the `update_amplification` function do not match the actual implementation parameters. The comments reference different parameter names and structures than what the code uses.,"This inconsistency can cause confusion for developers during code maintenance or when integrating with the pallet, potentially leading to incorrect usage.",Documentation,2025 Q1/hydration-oak-2503/hydration-oak-2503.json
HO-2503-14,Misleading error messages,Informational,pallets/stableswap,"The `ArithmeticError::Overflow` error is used incorrectly in several places to report general validation issues, not just arithmetic overflows. Additionally, the `IncorrectAssets` error is returned for duplicate assets, when a more specific `DuplicatedAssets` error would be clearer.","Imprecise error messages make it harder for developers and users to diagnose the root cause of a problem, slowing down debugging and incident response.",Implementation,2025 Q1/hydration-oak-2503/hydration-oak-2503.json
HO-2503-15,Missed invariant verification,Informational,pallets/stableswap,"The `ensure_remove_liquidity_invariant` is verified during `remove_liquidity` and `remove_liquidity_one_asset` but is not verified in the `withdraw_asset_amount` function, which is also a form of liquidity removal.",The lack of this invariant check in one of the liquidity removal paths creates an inconsistency that could potentially hide bugs or regressions in that specific code path.,Implementation,2025 Q1/hydration-oak-2503/hydration-oak-2503.json
HO-2503-16,Redundant balance validations,Informational,pallets/stableswap,"The code includes several redundant assertions for user balances during liquidity withdrawals and deposits. For example, it checks if a user has enough shares to withdraw, but the underlying `T::Currency::withdraw` call would fail anyway if the balance is insufficient.","These redundant assertions reduce code readability and add marginal, unnecessary overhead to transaction processing.",Implementation,2025 Q1/hydration-oak-2503/hydration-oak-2503.json
HO-2503-17,Unresolved TODO comments in the codebase,Informational,pallets/stableswap,"Two `TODO` comments were identified in the `pallets/stableswap/src/lib.rs` file. In general, `TODO` and `FIXME` comments tend to accumulate without resolution and can become outdated.","Leaving `TODO` comments in the code can reduce long-term maintainability and readability, as they represent unresolved issues or technical debt.",Documentation,2025 Q1/hydration-oak-2503/hydration-oak-2503.json
potential-loss-of-funds-due-to-can-deposit-error-during-the-refund-process--pallet-bonded-coins--high,Potential loss of funds due to can_deposit error during the refund process,High,pallet-bonded-coins,"The refund_account extrinsic allows users to burn bonded tokens to claim collateral. However, a failure in the can_deposit check, for reasons such as the MaxConsumers limit being reached, is not handled correctly. This results in the user's tokens being burned while the collateral is not deposited into their account.","This flaw can lead to an irreversible loss of user funds, as their tokens are destroyed but the corresponding collateral is not returned.",Implementation,2025 Q1/kilt-oak-2502/kilt-oak-2502.json
configurations-of-polynomialparameters-can-lead-to-overflow--pallet-bonded-coins--low,Configurations of PolynomialParameters can lead to overflow,Low,pallet-bonded-coins,The implementation of the polynomial curve cost calculation lacks validation to restrict parameter values that could cause an arithmetic overflow. The `calculate_costs` function is susceptible to overflow due to squared operations on its parameters.,"An overflow during minting operations could lead to a locked pool where no further tokens can be minted, effectively causing a denial of service for that specific pool.",Input Validation,2025 Q1/kilt-oak-2502/kilt-oak-2502.json
the-maxconsumers-constraint-limits-multi-asset-pool-usability--pallet-bonded-coins--low,The MaxConsumers constraint limits multi-asset pool usability,Low,pallet-bonded-coins,"The pallet allows creating a pool with up to 50 currencies, but the chain's `MaxConsumers` limit restricts an account to holding only 16 non-sufficient assets. This constraint prevents users from participating in pools with a large number of currencies if they need to hold balances in many of them.","The usability and flexibility of multi-asset pools are significantly reduced, as pool designs that require a user to interact with more than 16 currencies become impractical.",Design,2025 Q1/kilt-oak-2502/kilt-oak-2502.json
incomplete-asset-cleanup-in-finish-destroy-extrinsic-may-leave-residual-tokens--pallet-bonded-coins--low,Incomplete asset cleanup in finish_destroy extrinsic may leave residual tokens,Low,pallet-bonded-coins,"The `finish_destroy` extrinsic, which completes a pool's destruction, does not account for tokens still held by users, particularly if the destruction was initiated forcibly. The function finalizes asset destruction without ensuring all user-held tokens have been burned.","Residual tokens may remain in user accounts after a pool is destroyed, leading to an inconsistent state and potential issues with supply accounting.",Implementation,2025 Q1/kilt-oak-2502/kilt-oak-2502.json
centralization-risks--pallet-bonded-coins--low,Centralization risks,Low,pallet-bonded-coins,"Multiple centralization risks were identified, granting excessive power to privileged roles. The pool manager can trigger pool destruction, freeze assets, and modify the management team. Furthermore, some administrative actions require root access (ForceOrigin), centralizing power in a single entity.",Excessive control by a pool manager or root account can undermine the system's trustlessness and could be abused to manipulate markets or misappropriate funds.,Design,2025 Q1/kilt-oak-2502/kilt-oak-2502.json
possibility-of-setting-different-management-teams-for-assets-within-the-same-pool--pallet-bonded-coins--low,Possibility of setting different management teams for assets within the same pool,Low,pallet-bonded-coins,"The `reset_team` function updates the management team for only a single currency at a time. Since a pool can contain multiple currencies, this can create a scenario where different entities manage different currencies within the same pool.","Inconsistent control across assets in a single pool can lead to unexpected behavior and operational disruptions, especially if one currency is frozen while others are not.",Access Control,2025 Q1/kilt-oak-2502/kilt-oak-2502.json
unused-owner-parameter-in-reset-team-function--pallet-bonded-coins--informational,Unused _owner parameter in reset_team function,Informational,pallet-bonded-coins,"The `reset_team` function implementation within the traits module includes an `_owner` parameter that is never used. The function logic ignores this parameter and instead retrieves the owner directly from the `AssetsPallet`, which could lead to incorrect assumptions in the code.",The unused parameter can cause confusion for developers and potentially lead to mismatches or incorrect assumptions about the function's behavior.,Implementation,2025 Q1/kilt-oak-2502/kilt-oak-2502.json
missing-validations-of-currencies-list-during-pool-creation--pallet-bonded-coins--informational,Missing validations of currencies list during pool creation,Informational,pallet-bonded-coins,"The `create_pool` extrinsic lacks validation to prevent multiple currencies with identical metadata (name and symbol) from being created within the same pool. Additionally, it does not enforce a non-empty pool constraint, allowing for the creation of empty, non-functional pools.","Allowing duplicate currency metadata can cause user confusion, while the creation of empty pools serves no functional purpose and clutters the state.",Input Validation,2025 Q1/kilt-oak-2502/kilt-oak-2502.json
minimal-error-handling-in-try-from-implementation--pallet-bonded-coins--informational,Minimal error handling in try_from implementation,Informational,pallet-bonded-coins,"The `try_from` implementation in the square-root curve logic uses a simplistic error type, returning an empty `()` value on failure. This provides no context about the nature of the conversion failure.",The lack of detailed error information makes debugging and error handling more challenging for developers and users interacting with the pallet.,Implementation,2025 Q1/kilt-oak-2502/kilt-oak-2502.json
redundant-defensive-assertion-in-refund-account-function--pallet-bonded-coins--informational,Redundant defensive assertion in refund_account function,Informational,pallet-bonded-coins,A defensive assertion in the `refund_account` function checks if `sum_of_issuances` is greater than or equal to the `burnt` amount. This check is redundant because the logic immediately preceding it guarantees this condition is always met.,"While not harmful, the redundant code adds unnecessary complexity and can be removed to simplify the codebase.",Implementation,2025 Q1/kilt-oak-2502/kilt-oak-2502.json
inconsistent-pool-lock-state--pallet-bonded-coins--informational,Inconsistent pool lock state,Informational,pallet-bonded-coins,The `set_lock` extrinsic allows a pool to be marked as `PoolStatus::Locked` even if minting and burning operations are still enabled. The function does not validate that both `allow_mint` and `allow_burn` are set to false when applying the locked status.,"This can lead to an inconsistent state where a pool appears to be locked but operations are still permitted, potentially confusing users and dApp developers.",Implementation,2025 Q1/kilt-oak-2502/kilt-oak-2502.json
possible-optimization-in-polynomial-curve--pallet-bonded-coins--informational,Possible optimization in polynomial curve,Informational,pallet-bonded-coins,"The `calculate_costs` function in the polynomial curve implementation performs calculations for terms involving coefficients `m` and `n` without first checking if they are zero. If a coefficient is zero, the corresponding calculation is redundant.",Unnecessary computations consume computational overhead. Adding pre-checks for zero-value coefficients would bypass these calculations and improve efficiency.,Implementation,2025 Q1/kilt-oak-2502/kilt-oak-2502.json
manager-change-allowed-in-destroying-state-pools--pallet-bonded-coins--informational,Manager change allowed in destroying state pools,Informational,pallet-bonded-coins,The `reset_manager` function does not prevent a manager change for a pool that is in a non-live or destroying state. Allowing a manager change for a pool being decommissioned could lead to inconsistencies.,Permitting manager changes on pools being destroyed could lead to unintended control transfers or complicate the decommissioning process.,Access Control,2025 Q1/kilt-oak-2502/kilt-oak-2502.json
contracts-should-implement-a-two-step-ownership-transfer--pallet-bonded-coins--informational,Contracts should implement a two-step ownership transfer,Informational,pallet-bonded-coins,"The `reset_manager` extrinsic uses a one-step ownership transfer, which presents a risk of losing ownership if the new owner's address is incorrect. A two-step process, where a new owner is proposed and must then claim ownership, is recommended to prevent this.","A one-step transfer risks permanent loss of contract control if an incorrect address is provided, potentially locking the pool's administrative functions.",Design,2025 Q1/kilt-oak-2502/kilt-oak-2502.json
unresolved-todo-and-fixme-comments-in-the-codebase--unspecified--informational,Unresolved TODO and FIXME comments in the codebase,Informational,unspecified,"Over 40 `TODO` and `FIXME` comments were identified throughout the codebase. These comments indicate areas with pending tasks, known issues, or required improvements that have not yet been addressed.",Leaving unresolved `TODO` and `FIXME` comments can lead to technical debt and may hide potential underlying issues that should be addressed.,Documentation,2025 Q1/kilt-oak-2502/kilt-oak-2502.json
missing-event-emission-for-reset-team--pallet-bonded-coins--informational,Missing event emission for reset_team,Informational,pallet-bonded-coins,"The `reset_team` extrinsic, which updates administrative roles like admin and freezer, does not emit an event upon successful execution. This lack of notification makes it difficult for off-chain tools and listeners to track administrative changes.","Without an event, off-chain tracking and governance monitoring systems may become inconsistent with the on-chain state of administrative roles.",Implementation,2025 Q1/kilt-oak-2502/kilt-oak-2502.json
redundant-manager-and-team-updates-are-allowed--pallet-bonded-coins--informational,Redundant manager and team updates are allowed,Informational,pallet-bonded-coins,The `reset_team` and `reset_manager` extrinsics do not validate whether the new values being set are different from the existing ones. This allows for redundant updates to be executed.,Executing redundant updates consumes system resources and transaction fees unnecessarily without changing the system's state.,Implementation,2025 Q1/kilt-oak-2502/kilt-oak-2502.json
dependencies-are-subject-to-publicly-known-vulnerabilities--unspecified--informational,Dependencies are subject to publicly known vulnerabilities,Informational,unspecified,"The project's dependencies are not up-to-date and contain publicly known vulnerabilities in libraries such as `rustls`, `curve25519-dalek`, and `idna`. Additionally, some dependencies like `parity-util-mem` are deprecated.",Using outdated dependencies with known vulnerabilities can expose the project to security risks that have already been discovered and fixed in newer versions.,Dependency,2025 Q1/kilt-oak-2502/kilt-oak-2502.json
implementation-error-allows-attackers-to-impersonate-any-circuitrole--circuit-pallet--high,Implementation error allows attackers to impersonate any CircuitRole,High,Circuit pallet,"A coding error in the `authorize` function within the Circuit pallet allows any user to impersonate critical roles such as Requester, Relayer, and Executor. The function correctly checks for a signed origin but fails to validate that the caller actually possesses the specified `CircuitRole`, thereby allowing any user to execute permissioned extrinsics.","Any user can impersonate infrastructure-critical users and perform permissioned transactions, such as bidding on side effects, escrowing funds, or canceling transactions.",Authorization,2024 H1/2401-t3rn-srl/2401-t3rn-srl.json
extrinsic-allows-takeover-of-gateways-escrow-account--xdns-pallet--high,Extrinsic allows takeover of gateway's escrow account,High,Xdns pallet,"The `reboot_self_gateway` extrinsic in the xdns pallet can be called by any signed user, who can then set their own account as the gateway's escrow account. This is because the logic uses the caller's signed account ID to establish the new escrow, lacking a necessary permission check to restrict this action to a root or admin origin.","An attacker can take over a gateway's escrow account, leading to fraudulent transactions and the complete loss of escrowed funds.",Access Control,2024 H1/2401-t3rn-srl/2401-t3rn-srl.json
underweight-extrinsics-may-cause-block-production-timeout--circuit-pallet--high,Underweight extrinsics may cause block production timeout,High,Circuit pallet,"Multiple extrinsics within the circuit pallet have weights that were benchmarked without considering worst-case computational scenarios, such as iterating over a list of maximum possible length. This oversight allows for the creation of blocks that are heavier than the network expects.","Attackers can craft transactions that create overweight blocks, potentially causing block production timeouts. This can significantly slow down transaction processing and could stall the chain if validators consistently miss their block production slots.",Operational,2024 H1/2401-t3rn-srl/2401-t3rn-srl.json
general-benchmarking-mismatch-across-multiple-extrinsics--circuit-and-xdns-pallets--high,General benchmarking mismatch across multiple extrinsics,High,Circuit and xdns pallets,"In the circuit and xdns pallets, some extrinsics reuse weight functions from other, different extrinsics. This practice leads to a mismatch between the actual computational requirements of an extrinsic and its assigned execution cost, resulting in underweighted transactions.","The use of inaccurate, under-weighted extrinsics enables the creation of overweight blocks, which can disrupt block production and potentially halt the chain.",Operational,2024 H1/2401-t3rn-srl/2401-t3rn-srl.json
extrinsics-that-have-default-weights-should-be-properly-benchmarked--circuit-and-attesters-pallets--high,Extrinsics that have default weights should be properly benchmarked,High,Circuit and attesters pallets,"Several extrinsics across the t3rn codebase are assigned a default, hardcoded weight rather than a weight derived from proper benchmarking. For instance, the `claim` extrinsic in the circuit pallet lacks authentication and uses a default weight, allowing any user to call it without paying a fee appropriate for its execution time.","This allows malicious actors to spam the blockchain with computationally intensive transactions at a low cost, potentially bloating block size and stalling the chain.",Operational,2024 H1/2401-t3rn-srl/2401-t3rn-srl.json
insecure-randomness-algorithm-for-attesters-shuffling--runtime--medium,Insecure randomness algorithm for Attester's shuffling,Medium,Runtime,"The selection of Attesters is randomized using the `RandomnessCollectiveFlip` pallet, which derives its seed from the hashes of the last 81 blocks. This method is known to be insecure for production environments as the outcome is predictable.","A malicious collator who is also an active participant in the Attesters set could predict and manipulate the randomness outcome. This would allow them to ensure their own selection in future committees, gaining an unfair financial advantage.",Cryptography,2024 H1/2401-t3rn-srl/2401-t3rn-srl.json
overlapping-values-for-isteleporter-and-isreserve--runtime--medium,Overlapping values for IsTeleporter and IsReserve,Medium,Runtime,"In the XCM configuration, the `IsTeleporter` and `IsReserve` settings are configured with overlapping values for native assets. This allows the same assets to be both teleported and reserve-transferred from the relay chain, a practice that should be mutually exclusive for a given asset.",An attacker can exploit this misconfiguration to drain funds from the `CheckedAccount` by repeatedly reserve-transferring and teleporting back the same assets. This would cause a denial-of-service for legitimate users.,Configuration,2024 H1/2401-t3rn-srl/2401-t3rn-srl.json
identityfee-used-to-configure-weighttofee--runtime--medium,IdentityFee used to configure WeightToFee,Medium,Runtime,"The `TransactionPayment` pallet is configured to use `IdentityFee` for its `WeightToFee` implementation. This sets the transaction fee equal to its weight, without applying any scaling or conversion, and fails to account for the network's current economic conditions or congestion.","This simplistic fee calculation can lead to a significant underestimation of transaction fees, allowing malicious network participants to spam the chain with cheap transactions.",Design,2024 H1/2401-t3rn-srl/2401-t3rn-srl.json
incorrect-benchmarks-for-dependency-pallets--runtime--low,Incorrect benchmarks for dependency pallets,Low,Runtime,"The project's benchmarks were generated using a generic template substrate-runtime, not the actual t3rn runtime. This approach fails to accurately measure the performance of dependency pallets within the specific configuration of the t3rn parachain.",Incorrectly benchmarked weights can lead to overweight extrinsics becoming non-callable or underweight extrinsics creating network instability.,Operational,2024 H1/2401-t3rn-srl/2401-t3rn-srl.json
lack-of-authorization-in-extrinsic-exposes-potential-for-spamming--circuit-vacuum-pallet--informational,Lack of authorization in extrinsic exposes potential for spamming,Informational,Circuit/Vacuum pallet,"Several extrinsics, including `read_order_status` and `read_all_pending_order_status` in the Circuit/Vacuum pallet, do not have an origin check. This means they can be called by any entity on the network without authorization or fee payment.","The absence of an origin check allows attackers to waste chain resources by repeatedly calling these extrinsics, exposing the blockchain to spamming attacks at no cost to the attacker.",Authorization,2024 H1/2401-t3rn-srl/2401-t3rn-srl.json
static-calculation-of-weights-for-the-claim-reward-extrinsic-enables-dos-attack-vector--lend-market--high,Static calculation of weights for the claim_reward extrinsic enables DoS attack vector,High,lend-market,"The `claim_reward` function iterates over all existing markets to collect rewards. However, the extrinsic's weight calculation is static and does not account for the number of markets, meaning the fee does not correlate with the computational resources used. This allows for a situation where executing claims across many markets costs the same as a single claim.","An attacker could register a large number of markets and then execute the `claim_reward` extrinsic to overload chain nodes for a disproportionately small fee, potentially leading to a denial-of-service attack.",Design,2024 H1/2401-bifrost-oak/2401-bifrost-oak.json
price-feeder-centralization-risks--prices--medium,Price feeder centralization risks,Medium,prices,"In the `prices` pallet, the privileged `FeederOrigin` is permitted to set arbitrary emergency prices without any validation on the provided values. This could be exploited if the `FeederOrigin` key is compromised or if an incorrect price is submitted due to an input error, as even a price of zero is accepted.","A malicious actor with access to the `FeederOrigin` account could manipulate asset prices, leading to incorrect valuations and potentially causing widespread wrongful liquidations of user assets.",Access Control,2024 H1/2401-bifrost-oak/2401-bifrost-oak.json
multiple-foreign-asset-id-can-be-mapped-to-the-same-asset-id--prices--medium,Multiple foreign_asset_id can be mapped to the same asset_id,Medium,prices,"The `set_foreign_asset` extrinsic allows a privileged origin to map a `foreign_asset_id` to an `asset_id`. However, the function lacks a check to ensure the `asset_id` is not already associated with a different `foreign_asset_id`, permitting multiple foreign assets to be linked to the same internal asset.","This vulnerability could lead to market misconfigurations and unpredictable system behavior, as the protocol might not handle asset pricing and accounting correctly.",Implementation,2024 H1/2401-bifrost-oak/2401-bifrost-oak.json
missing-check-that-foreign-asset-id-is-specifically-of-the-foreignasset-type--prices--medium,Missing check that foreign_asset_id is specifically of the ForeignAsset type,Medium,prices,"The `set_foreign_asset` extrinsic does not verify that the provided `foreign_asset_id` is of the `ForeignAsset` type. It is only identified as a generic `CurrencyId`, allowing the privileged `UpdateOrigin` to map any asset type, not just foreign assets.","This could lead to incorrect system configurations and unexpected behavior if non-foreign assets are improperly mapped, potentially affecting asset management and pricing logic.",Input Validation,2024 H1/2401-bifrost-oak/2401-bifrost-oak.json
default-mantissa-precision-can-lead-to-an-incorrect-price--prices--medium,Default mantissa precision can lead to an incorrect price,Medium,prices,"The `get_asset_mantissa` function is used to determine the decimal precision for a given asset. If it cannot find the decimal information for a specified `asset_id`, it defaults to a precision of 12 decimals instead of returning an error.","An incorrect mantissa calculation due to a misconfiguration or missing asset information would lead to erroneous price valuations, affecting all financial calculations involving that asset.",Implementation,2024 H1/2401-bifrost-oak/2401-bifrost-oak.json
missing-validation-for-the-lend-token-id--lend-market--medium,Missing validation for the lend_token_id,Medium,lend-market,"The `force_update_market` function allows a privileged origin to assign a new `lend_token_id` to a market. However, it fails to verify whether the specified `lend_token_id` is already in use as a market, a check that is present elsewhere in the codebase.","This oversight could lead to inconsistencies in market configuration, as a token not designed to be a market could be assigned as one, potentially breaking market invariants and behavior.",Input Validation,2024 H1/2401-bifrost-oak/2401-bifrost-oak.json
the-force-update-market-extrinsic-could-break-existing-markets--lend-market--medium,The force_update_market extrinsic could break existing markets,Medium,lend-market,"The `force_update_market` function permits a privileged origin to forcibly replace an existing market's parameters without ensuring the coherence of the new data. For example, it could set a `collateral_factor` outside the valid [0,1] range.","A misconfigured or malicious update could break market operations, disrupt invariants, and potentially lead to a loss of funds for users interacting with the affected market.",Access Control,2024 H1/2401-bifrost-oak/2401-bifrost-oak.json
static-calculation-of-weights-for-the-update-liquidation-fee-collateral-extrinsic--lend-market--medium,Static calculation of weights for the update_liquidation_fee_collateral extrinsic,Medium,lend-market,"The `update_liquidation_fee_collateral` extrinsic takes a vector of collaterals as a parameter, but the weight calculation for the extrinsic is static. It does not account for the number of items in the `collaterals` vector.","The fee charged for the extrinsic is uncorrelated with the computational resources used, which could be exploited. This creates an unfair fee structure and a potential vector for inefficient resource usage.",Design,2024 H1/2401-bifrost-oak/2401-bifrost-oak.json
missing-validation-of-liquidate-incentive-reserved-factor-during-market-update--lend-market--medium,Missing validation of liquidate_incentive_reserved_factor during market update,Medium,lend-market,"When updating a market via the `update_market` function, the `liquidate_incentive_reserved_factor` parameter is not validated to be within the expected (0,1) range. This check is correctly performed when a market is first added, but is missing on update.","Setting this factor outside the valid range could lead to incorrect calculations of incentives during liquidations, potentially causing unexpected financial losses or gains and breaking market mechanics.",Input Validation,2024 H1/2401-bifrost-oak/2401-bifrost-oak.json
incorrect-interest-is-calculated-if-requested-before-market-initialization--lend-market--medium,Incorrect interest is calculated if requested before market initialization,Medium,lend-market,"When the `get_market_status` function is called for a market that has not yet been used, the `last_accrued_interest_time` variable defaults to zero. This causes the interest accrual period to be inaccurately computed from January 1, 1970.","This leads to a significant miscalculation of interest for the market, which could result in incorrect accounting and financial reporting until the market is properly initialized.",Implementation,2024 H1/2401-bifrost-oak/2401-bifrost-oak.json
inefficient-active-markets-search--lend-market--informational,Inefficient active markets search,Informational,lend-market,"The `ensure_active_market` function searches for a market by iterating through all markets with O(n) complexity. This operation could be performed in constant time, O(1), by using the `market` storage map directly.","The current implementation causes the execution to incur higher gas costs due to unnecessary iteration, reducing the overall efficiency of the protocol.",Implementation,2024 H1/2401-bifrost-oak/2401-bifrost-oak.json
inefficient-market-data-aggregation--lend-market--informational,Inefficient market data aggregation,Informational,lend-market,"The `get_lf_base_position` function iterates through all active markets to aggregate collateral data. However, the queried market data is not retained, even though it is re-queried later by another function, leading to redundant calculations.","This causes the execution to incur higher costs due to unnecessary and repeated storage reads and calculations, making the operation less efficient.",Implementation,2024 H1/2401-bifrost-oak/2401-bifrost-oak.json
redundant-storage-queries--lend-market--informational,Redundant storage queries,Informational,lend-market,"The `pallets/lend-market/src/lib.rs` file exhibits multiple instances of redundant on-chain storage queries. For example, storage is first checked for a key's existence and then a second query is made to fetch the value, where a single query would suffice.","Minimizing the number of storage queries would enhance both performance and code clarity, leading to lower gas costs and a more efficient implementation.",Implementation,2024 H1/2401-bifrost-oak/2401-bifrost-oak.json
code-duplication--lend-market--informational,Code duplication,Informational,lend-market,"The `pallets/lend-market/src/lib.rs` file contains multiple instances of duplicated code logic. For example, the code fragments in lines 1144-1152 and 1158-1166 are nearly identical, as are fragments in lines 1312-1325 and 1280-1293.","Code duplication undermines maintainability and increases the risk of introducing bugs, as fixes and updates must be applied in multiple places.",Implementation,2024 H1/2401-bifrost-oak/2401-bifrost-oak.json
the-get-special-asset-price-function-consistently-returns-none--prices--informational,The get_special_asset_price function consistently returns None,Informational,prices,"In `pallets/prices/src/lib.rs`, the `get_special_asset_price` function is designed to return a `TimeStampedPrice` value. However, the implementation consistently returns `None`, rendering the function ineffective.","This behavior is misleading to developers and callers of the function, and it represents dead code that serves no purpose, potentially indicating a logic error or incomplete implementation.",Implementation,2024 H1/2401-bifrost-oak/2401-bifrost-oak.json
inefficient-reduce-reserves-extrinsic-execution-in-case-of-reduce-reserves-parameter-equal-to-zero--lend-market--informational,Inefficient reduce_reserves extrinsic execution in case of reduce_reserves parameter equal to zero,Informational,lend-market,"The `reduce_reserves` extrinsic takes a `reduce_amount` as a parameter. If this amount is zero, the function proceeds to perform all its operations unnecessarily, which is inefficient and could be misleading.","Executing the function with a zero amount wastes computational resources and gas, and could be prevented with a simple check at the beginning of the function.",Implementation,2024 H1/2401-bifrost-oak/2401-bifrost-oak.json
use-of-magic-numbers-decreases-maintainability--lend-market--informational,Use of magic numbers decreases maintainability,Informational,lend-market,"Throughout the codebase, hard-coded number literals are used without context or a descriptive name (e.g., in `farming.rs:28` and `rate_model.rs:173`). This practice, known as using 'magic numbers', goes against best practices.","Using magic numbers reduces code readability and maintainability, as developers cannot easily understand their purpose and may introduce inconsistencies when making changes.",Documentation,2024 H1/2401-bifrost-oak/2401-bifrost-oak.json
state-change-events-are-emitted-even-if-no-change-has-occurred--lend-market--informational,State change events are emitted even if no change has occurred,Informational,lend-market,"When updating market parameters, success events like `MarketRewardSpeedUpdated` or `UpdatedMarket` are emitted regardless of whether any state has actually changed. If no optional values are specified in the call, the state remains the same but an event is still emitted.","This is inconsistent with the function's logic and can be misleading for off-chain tools and UIs that rely on events to track state changes, leading to unnecessary processing.",Implementation,2024 H1/2401-bifrost-oak/2401-bifrost-oak.json
miscellaneous-comments--unspecified--informational,Miscellaneous comments,Informational,unspecified,"The report identifies several minor issues: an overflow error is incorrectly labeled as underflow, an `assert` should be a `use`, a `NotSupportTokenType` should be reworded, and an inequality should be `greater than or equal to` instead of just `greater than` based on implementation logic.","These minor issues relate to code clarity, correctness, and consistency. Addressing them would improve the overall quality and maintainability of the codebase.",Implementation,2024 H1/2401-bifrost-oak/2401-bifrost-oak.json
nexus-runtime-waives-xcm-message-delivery-fee--parachain-runtime-nexus--high,Nexus runtime waives XCM message delivery fee,High,parachain/runtime/nexus,"The Nexus runtime does not set the FeeManager for XCM configuration, waiving all fees for XCM messages. This allows an attacker to send messages without paying any delivery fee.","An attacker can cause network congestion, storage exhaustion, and dropping of messages by sending a high volume of free messages.",Configuration,2024 H1/2405-hyperbridge-srl/2405-hyperbridge-srl.json
no-xcm-delivery-fees-configured-for-sibling-parachain-messages--parachain-runtime-nexus--high,No XCM delivery fees configured for sibling parachain messages,High,parachain/runtime/nexus,"The Nexus runtime configuration sets the PriceForSiblingDelivery to NoPriceForMessageDelivery, meaning no fees are charged for XCM messages across parachains. This allows attackers to send spam messages across chains without payment.","Excessive spam messages could lead to XCM queue size exhaustion due to excessive storage usage, causing message delivery delays for legitimate users.",Configuration,2024 H1/2405-hyperbridge-srl/2405-hyperbridge-srl.json
stack-exhaustion-due-to-missing-decodelimit--modules-ismp-pallets-call-decompressor--high,Stack exhaustion due to missing DecodeLimit,High,modules/ismp/pallets/call-decompressor,The extrinsic `decompress_call` in `pallet-call-decompressor` accepts a compressed call that is decoded without a depth limit. An attacker can create deeply nested calls that exhaust the stack size during decoding due to excessive recursion.,"If a malicious call is sent through a bridge that requires forced execution, it could permanently stall the receiving chain, causing a denial of service.",Implementation,2024 H1/2405-hyperbridge-srl/2405-hyperbridge-srl.json
incorrect-weight-configuration-in-nexus-runtime--parachain-runtimes-nexus--high,Incorrect weight configuration in Nexus runtime,High,parachain/runtimes/nexus,"The weights for ISMP, XCM, and other Substrate pallets are misconfigured in the Nexus runtime, with some pallets using TestWeightInfo or weights set to zero. This makes the execution cost for these extrinsics effectively zero.","An attacker can spam the network with zero-cost transactions, leading to network storage bloating and degraded performance.",Configuration,2024 H1/2405-hyperbridge-srl/2405-hyperbridge-srl.json
missing-runtime-benchmark-for-ismp-pallets--parachain-runtimes-nexus--high,Missing runtime benchmark for ISMP pallets,High,parachain/runtimes/nexus,"The configurable weights for several pallets in the ISMP module, such as `pallet-assets` and `pallet-ismp`, are not included in the runtime benchmarks. This can result in overweight or underweight extrinsics.","Incorrect benchmarking can lead to low-effort attacks such as spamming, storage bloating, and block stalling when invoking the affected extrinsics.",Implementation,2024 H1/2405-hyperbridge-srl/2405-hyperbridge-srl.json
unsigned-extrinsics-allow-to-execute-ismp-messages-for-free--modules-ismp--high,Unsigned extrinsics allow to execute ISMP messages for free,High,modules/ismp,"ISMP messages are implemented as unsigned extrinsics, which allows a malicious attacker to freely execute these messages without being subject to fees or blacklisting. Although checks exist to prevent spamming the transaction pool, this can be circumvented if valid FraudProofMessages are sent repeatedly.","An attacker can spam the network with messages without facing any direct consequences, potentially leading to denial of service or network degradation.",Access Control,2024 H1/2405-hyperbridge-srl/2405-hyperbridge-srl.json
fishermen-can-veto-statecommitment-after-the-challenge-period--modules-ismp-pallets-fishermen--medium,Fishermen can veto StateCommitment after the challenge_period,Medium,modules/ismp/pallets/fishermen,"In the `veto_state_commitment` extrinsic, Fishermen can veto a `StateCommitment` without checking if the challenge period has elapsed. Fishermen are not required to submit fraud proofs, allowing them to repeatedly veto canonical chain states.","A compromised or rogue Fisherman could veto valid state commitments after the challenge period, creating instability and compromising the integrity of the system.",Design,2024 H1/2405-hyperbridge-srl/2405-hyperbridge-srl.json
missing-priority-in-fraud-proof-messages--modules-ismp--medium,Missing priority in Fraud Proof messages,Medium,modules/ismp,Fraud Proof messages are handled with the same priority as other ISMP message types. This can lead to a valid Fraud Proof being delayed or censored if there are many other messages in the queue.,A malicious consensus client can inflict more faults into the consensus mechanism and will not be frozen promptly if fraud proofs are not processed in a timely manner.,Design,2024 H1/2405-hyperbridge-srl/2405-hyperbridge-srl.json
same-consensus-client-can-be-frozen-repeatedly--modules-ismp--medium,Same consensus client can be frozen repeatedly,Medium,modules/ismp,"A valid Fraud Proof message submitted via an unsigned extrinsic can be used to freeze a byzantine consensus client. However, there is a lack of checks to prevent the same valid proof from being submitted multiple times to repeatedly freeze the same client.","A malicious user can spam the chain by repeatedly submitting the same valid Fraud Proof message for free, as they are sent via unsigned extrinsics.",Implementation,2024 H1/2405-hyperbridge-srl/2405-hyperbridge-srl.json
missing-benchmarking-to-calculate-weights--modules-ismp-pallets--low,Missing benchmarking to calculate weights,Low,modules/ismp/pallets,"The weights of extrinsics in the `call-decompressor`, `fishermen`, and `relayer` pallets are not based on benchmark values and instead have a fixed value. Incorrect fee calculation due to a lack of benchmarking can be exploited.","An attacker could exploit low fees to flood the network with transactions, which is a particular risk for unsigned extrinsics that can be submitted in large numbers.",Implementation,2024 H1/2405-hyperbridge-srl/2405-hyperbridge-srl.json
unbounded-loop-leading-to-block-production-stalling--modules-ismp-pallets-pallet--informational,Unbounded loop leading to block production stalling,Informational,modules/ismp/pallets/pallet,The `ismp-demo` pallet allows dispatching request messages to EVM chains via the `dispatch_to_evm` extrinsic. This extrinsic contains an unbounded loop that could be abused.,An attacker could call the extrinsic with a high `count` value to halt block production on the chain. The issue was closed as the demo pallet is not for production use.,Implementation,2024 H1/2405-hyperbridge-srl/2405-hyperbridge-srl.json
timeout-overflow-due-to-unsafe-arithmetic-in-request-dispatch--modules-ismp-pallets-demo--informational,Timeout overflow due to unsafe arithmetic in request dispatch,Informational,modules/ismp/pallets/demo,"When a request is dispatched via ISMP, a malicious actor can trigger an integer overflow in the `timeout_timestamp` computation by providing a very high number in the timeout field. This causes the timeout to represent a timestamp in the past.","The request will expire before it is even sent. While not a current security risk, it could become problematic if bridge operators are penalized for timeouts in the future.",Implementation,2024 H1/2405-hyperbridge-srl/2405-hyperbridge-srl.json
missing-fraud-proof-implementation-for-beacon-consensus-clients--modules-ismp-clients-sync-committee--informational,Missing Fraud Proof implementation for Beacon consensus clients,Informational,modules/ismp/clients/sync-committee,The `verify_fraud_proof` function is not implemented for the Beacon consensus client. Any attempt to submit a Fraud Proof message for the Beacon chain will be rejected.,"The Beacon consensus client cannot be frozen after an invalid consensus state, allowing the Relayer to continue relaying messages and resulting in multiple invalid transactions.",Implementation,2024 H1/2405-hyperbridge-srl/2405-hyperbridge-srl.json
failure-of-transfer-success-may-result-in-unexpected-behavior--evm-src-hosts-evmhost-sol--high,Failure of transfer success may result in unexpected behavior,High,evm/src/hosts/EvmHost.sol,There are multiple instances of unchecked return values when interacting with the `transfer()` and `transferFrom()` functions of external ERC-20 contracts. This makes it impossible to halt execution upon failed transfers.,"In the case of `fundRequest()` and `fundResponse()`, the funding status and value would be recorded incorrectly regardless of whether the token transfer succeeded, leading to undefined system behavior and potential financial loss.",Implementation,2024 H1/2405-hyperbridge-srl/2405-hyperbridge-srl.json
denial-of-service-to-host-configuration-updates--evm-src-hosts-evmhost-sol--medium,Denial of service to host configuration updates,Medium,evm/src/hosts/EvmHost.sol,"When the host configuration `_hostParams` is updated, the logic iterates over an unbounded storage array `_hostParams.fishermen`. If the number of entries in this array is set too high by the host manager, it would be impossible to update any configuration parameters.","A misconfiguration would cause the update transaction to revert with an out-of-gas error, permanently locking the host configuration.",Implementation,2024 H1/2405-hyperbridge-srl/2405-hyperbridge-srl.json
configuration-could-be-locked-without-zero-address-sanity-checks--evm-src-hosts-evmhost-sol--low,Configuration could be locked without zero-address sanity checks,Low,evm/src/hosts/EvmHost.sol,"When updating the host parameters via `updateHostParamsInternal()`, the `hostManager` data field is not checked for the zero-address. A misconfiguration of this field would make the function unreachable.","If the `hostManager` is accidentally set to the zero-address, all host configurations would be permanently locked as the update function would be inaccessible.",Input Validation,2024 H1/2405-hyperbridge-srl/2405-hyperbridge-srl.json
configuration-could-be-locked-due-to-the-finality-of-updates--evm-src-hosts-evmhost-sol--low,Configuration could be locked due to the finality of updates,Low,evm/src/hosts/EvmHost.sol,"Updates to the privileged `hostManager` contract address are done in a single step, which increases the attack surface for misconfiguration and human error. There is no confirmation step or escape clause.","A misconfiguration, such as setting a new `hostManager` address that lacks required functionality, would be unrectifiable and could permanently lock critical host functionality.",Process,2024 H1/2405-hyperbridge-srl/2405-hyperbridge-srl.json
missing-event-emissions-would-impede-off-chain-monitoring--evm-src--low,Missing event emissions would impede off-chain monitoring,Low,evm/src,"Throughout the codebase, there are instances of unsatisfactory support for off-chain monitoring solutions, as the transmission of necessary system data via events was often neglected. This makes it difficult to track system activity and respond to incidents.","The inability to efficiently triage live exploits in a timely manner would amplify the associated impact of any given exploit, as remediation is more challenging when caught late.",Operational,2024 H1/2405-hyperbridge-srl/2405-hyperbridge-srl.json
gas-optimization-report--evm-src--informational,Gas optimization report,Informational,evm/src,"Multiple instances were found where source code logic could be optimized to improve runtime transaction fees. This includes using `++i` instead of `i++` in loops, using `!= 0` instead of `> 0` for unsigned integers, and using custom errors instead of require statements.","Inefficient Solidity source code results in higher execution costs for users, which may negatively impact community sentiment and increase operational overhead.",Implementation,2024 H1/2405-hyperbridge-srl/2405-hyperbridge-srl.json
H-01,"An attacker possesses the capability to exhaust the entirety of liquidity within the stable swap pools by manipulating the buy function, specifically by setting the asset_in parameter equal to the asset_out parameter",High,stableswap,"The buy() function in the Stableswap pallet does not validate if the input asset is the same as the output asset. An attacker can call the buy function with asset_in equal to asset_out, which results in the calculation of amount_in to be near zero, allowing the attacker to drain funds with minimal cost.","This vulnerability allows a malicious actor to drain all liquidity from any pool in the Stableswap pallet without requiring special permissions, leading to significant financial losses for both the protocol and liquidity providers.",Input Validation,2024 H1/2401-hydradx-c4/2401-hydradx-c4.json
M-01,Users can MAKE EMA-Oracle price outdated with direct transfers to StableSwap,Medium,EMA Oracle,The EMA oracle's price information can be manipulated because direct asset transfers to the StableSwap contract do not trigger the oracle's update hooks. This causes a discrepancy between the actual asset prices in the liquidity pools and the prices reported by the oracle.,"A malicious user can intentionally create outdated prices in the oracle, which could lead to unfair liquidations or other incorrect behavior in third-party protocols that rely on this oracle for price data.",Design,2024 H1/2401-hydradx-c4/2401-hydradx-c4.json
M-02,Malicious liquidity provider can put pool into highly manipulatable state,Medium,stableswap,"The `withdraw_asset_amount()` function for withdrawing liquidity from a StableSwap pool omits a check on the total pool liquidity. This allows a malicious liquidity provider to leave a very small amount of liquidity (e.g., 1 share) in the pool, breaking the `totalPoolIssuance >= MinPoolLiquidity` invariant.",Breaking the minimum liquidity invariant makes the pool highly susceptible to price manipulation and can cause a denial-of-service for other users trying to withdraw liquidity via other functions that correctly check the invariant.,Implementation,2024 H1/2401-hydradx-c4/2401-hydradx-c4.json
M-03,No slippage check in remove_liquidity function in omnipool can lead to slippage losses during liquidity withdrawal.,Medium,omnipool,The `remove_liquidity` function in the omnipool pallet does not have a `minimum_amount_out` parameter or any other form of slippage protection. This allows a malicious user to frontrun a liquidity withdrawal transaction with a swap that negatively impacts the price.,"Liquidity providers can suffer significant slippage losses when withdrawing their funds, as a frontrunner can manipulate the asset price between the time the transaction is submitted and when it is executed.",Implementation,2024 H1/2401-hydradx-c4/2401-hydradx-c4.json
M-04,Complete liquidity removals fail from stableswap pools,Medium,stableswap,"When a user attempts to remove the entire liquidity of a stableswap pool, the transaction reverts due to an arithmetic overflow. The internal mathematics of the stableswap algorithm fail when there is no liquidity remaining.","This issue can lead to temporarily locked funds in edge cases, as the initial liquidity provider cannot remove their entire position from the pool once it's established.",Implementation,2024 H1/2401-hydradx-c4/2401-hydradx-c4.json
M-05,No safe_withdrawal option in withdraw_protocol_liquidity function in omnipool can be abused by frontrunners to cause losses to the admin when removing liquidity,Medium,omnipool,"The `withdraw_protocol_liquidity` function, used by the admin, lacks a slippage protection mechanism. The admin must pass in a price parameter, but a frontrunner can manipulate the spot price to be different from the price passed in, causing the admin to eat losses.","If the spot price is manipulated after the admin submits the transaction, the protocol can suffer significant losses due to slippage, which can be much higher than the standard limits because the check is missing entirely.",Access Control,2024 H1/2401-hydradx-c4/2401-hydradx-c4.json
M-06,complete liquidity removal will result in permanent disable of the liquidity addition and prevent minting shares for the liquidity providers.,Medium,omnipool,"If all liquidity is removed from an omnipool asset pool, the asset_reserve and shares become zero. The `add_liquidity` function cannot handle this state and will always revert due to a division-by-zero error when trying to calculate new shares to mint.","This creates a permanent denial-of-service for the affected asset pool. No new liquidity can ever be added, and trading is disabled forever, leading to a loss of funds for the protocol and users.",Implementation,2024 H1/2401-hydradx-c4/2401-hydradx-c4.json
M-07,Re-adding assets to the omnipool can cause a problem with the oracle,Medium,omnipool,"When an asset is removed from the omnipool, its data records are deleted from the omnipool state, but not from the EMA oracle. If the asset is added back later at a different price, the oracle calculates the new price using stale, historical data from before the asset was removed.","The oracle will report a falsified, incorrect price for the re-added asset for a period of time. This can cause transactions to fail and could be exploited by protocols that rely on this oracle.",Implementation,2024 H1/2401-hydradx-c4/2401-hydradx-c4.json
M-08,Storage can be bloated with low value liquidity positions,Medium,omnipool,"A malicious user can create a large number of very small liquidity positions. By depositing the minimum required liquidity and then withdrawing all but one token, the user can bloat the `Positions` storage map with dust entries at a very low cost.","This constitutes a denial-of-service attack by bloating the chain's storage. The protocol itself must bear the storage costs for these dust positions, which can hinder functionality.",Design,2024 H1/2401-hydradx-c4/2401-hydradx-c4.json
M-09,Missing hook call will lead to incorrect oracle results,Medium,omnipool,"The `remove_token` function in the omnipool, which transfers all remaining protocol-owned liquidity to a beneficiary, fails to call the `on_liquidity_changed` hook. This hook is responsible for updating the EMA oracle and circuit breaker with the new state.",The oracle and circuit breaker will have outdated information about the pool's liquidity. This can lead to incorrect price reporting by the oracle and the failure of security measures that rely on accurate liquidity data.,Implementation,2024 H1/2401-hydradx-c4/2401-hydradx-c4.json
M-10,A huge loss of funds for all the users who try to remove liquidity after swapping got disabled at manipulated price.,Medium,omnipool,"The `set_asset_tradable_state` function can be used to disable swaps on an asset while still allowing liquidity removal, but it does not check if the oracle price is stable. An attacker can manipulate the price, disable swaps, and then front-run users who try to remove liquidity.","When a user removes liquidity while the price is manipulated and swaps are disabled, the `calculate_withdrawal_fee` function can calculate a 100% fee. This results in the user losing their entire liquidity position.",Design,2024 H1/2401-hydradx-c4/2401-hydradx-c4.json
double-spending-of-tokens-via-infinite-staking-on-unlock--pallets-dapp-staking-v3--critical,Double spending of tokens via infinite staking on unlock,Critical,pallets/dapp-staking-v3,"The unlocking logic in dapp-staking-v3 allows an attacker to double spend tokens. A user can unlock tokens, transfer them to another account, and then use the 'relock_unlocking' function to make the non-existent tokens available for staking again in the original account.","An attacker can stake the same tokens multiple times across different accounts, leading to gaining undue rewards and potentially tampering with the network's inflation scheme.",Implementation,2024 H1/2401-astar-srl/2401-astar-srl.json
payouts-round-down-to-zero-for-collator-and-treasury-rewards--pallets-inflation--high,Payouts round down to zero for collator and treasury rewards,High,pallets/inflation,"Due to integer division in the inflation calculation logic, the rewards per block for collators and the treasury can be rounded down to zero. This occurs if the configured emission rate for a cycle is smaller than the number of blocks in that cycle.","Collators may not receive rewards for producing blocks, which could deter participation and disrupt the staking mechanism. This breaks the economic model and could lead to free balances floating in the system.",Implementation,2024 H1/2401-astar-srl/2401-astar-srl.json
unregistered-dapps-not-removed-from-storage--pallets-dapp-staking-v3--medium,Unregistered dApps not removed from storage,Medium,pallets/dapp-staking-v3,"When a dApp is unregistered, its state is marked as 'Unregistered' but it is not removed from the 'IntegratedDApps' storage count. This count is checked against the 'MaxNumberOfContracts' limit, meaning that over time, the accumulation of unregistered dApps can prevent new, valid dApps from registering.","This can prevent new dApp developers from registering their applications, effectively halting ecosystem growth. It would require a manual and expensive runtime upgrade to fix by increasing the limit or cleaning the storage.",Implementation,2024 H1/2401-astar-srl/2401-astar-srl.json
loyal-staker-status-can-be-abused--pallets-dapp-staking-v3--low,Loyal staker status can be abused,Low,pallets/dapp-staking-v3,"A staker achieves 'loyal' status by staking at least once in a voting period. However, they can unstake their entire balance within the same period and still retain this loyal status for the next period, despite having no active stake.","This flaw disrupts the concept of loyalty, as a staker with zero balance maintains a privileged status. This could be exploited if dApp developers use the 'loyal staker' status for special payouts or other privileges.",Design,2024 H1/2401-astar-srl/2401-astar-srl.json
potential-spamming-attack-via-unsigned-dispatch-permit-extrinsic--pallet-transaction-multi-payment--medium,Potential spamming attack via unsigned dispatch_permit extrinsic,Medium,pallet-transaction-multi-payment,"The `dispatch_permit` extrinsic allows for unsigned transactions that perform computationally heavy validation. Since the extrinsic is unsigned, no fees are paid, creating an attack vector. This can be exploited by submitting numerous unsigned extrinsics, potentially leading to a denial-of-service (DoS) attack on the network.","An attacker can spam the network with unsigned transactions, causing high computational load on collators/validators, network congestion, and performance degradation, effectively slowing down the chain.",Design,2024 H1/2405-hydradx-srl/2405-hydradx-srl.json
the-mapping-between-ethereum-and-substrate-addresses-could-create-unwanted-behavior--pallet-evm-accounts--informational,The mapping between Ethereum and Substrate addresses could create unwanted behavior,Informational,pallet-evm-accounts,"The system maps EVM addresses to Substrate addresses by creating a truncated address, which is against best practices and reduces address entropy. When a user transfers funds to an EVM address that is not bound to a Substrate account, the funds are sent to a truncated address that cannot be claimed by any user.",Legitimate users could permanently lose funds by unintentionally transferring them to an EVM address that does not have a corresponding bound Substrate account.,Design,2024 H1/2405-hydradx-srl/2405-hydradx-srl.json
weight-calculation--assets-pallet-chain-extension--low,Weight calculation,Low,Assets Pallet Chain Extension,"All the assets pallet functions exposed by the chain extension are weighted with a constant amount. Two functions, MetadataSymbol and MetadataName, operate on a variable amount of data, but they also only account for one runtime database read operation.","While using a constant weight is not believed to cause significant issues, the currently used weights do not fairly represent the load imposed on the network by smart contracts invoking the operations exposed by the extension.",Implementation,2024 H1/2401-astar-zellic/2401-astar-zellic.json
unexposed-functionality--assets-pallet-chain-extension--informational,Unexposed functionality,Informational,Assets Pallet Chain Extension,"The chain extension does not expose all the functionality available from the assets pallet, which is a deliberate and documented choice. For instance, the extension exposes the `approve_transfer` function but not the corresponding `cancel_approval` function, preventing the revocation of approvals.","Smart contracts are able to grant approval over an asset to other addresses, but they are unable to revoke that approval, as the allowance can only be increased.",Design,2024 H1/2401-astar-zellic/2401-astar-zellic.json
issue-8,All XCM fee payments are waived due to setting FeeManager to the unit type,High,Tinkernet Runtime,The current XcmConfig for both the tinkernet and invarch runtimes effectively waives all fee payments by configuring the FeeManager to a unit type. This renders fee-based congestion control ineffective as no fees are actually charged for XCM transactions.,"Attackers can cause network congestion by sending a high volume of transactions at no cost, potentially leading to long delivery delays, storage exhaustion, or the dropping of messages.",Configuration,2024 H1/2402-invarch-srl/2402-invarch-srl.json
issue-7,No XCM delivery fees configured for sibling parachain messages,High,Tinkernet Runtime,No fees are charged for delivering XCM messages across parachains because the `PriceForSiblingDelivery` in the tinkernet runtime configuration is set to zero. This allows for free cross-chain messaging.,"Attackers can send spam messages to other chains without paying a fee, potentially causing XCM queue exhaustion and delays in message delivery for legitimate users.",Configuration,2024 H1/2402-invarch-srl/2402-invarch-srl.json
issue-6,Underestimated worst-case weight for OcifStaking::unregister_core,High,OCIF Pallet,"The `unregister_core` extrinsic in the OcifStaking pallet underestimates its worst-case execution weight by a factor of 100. A single call can unstake up to `MaxStakersPerCore` unique stakers, but the weight calculation does not properly account for this.","The underestimated weight allows an attacker to create overweight blocks, which can cause block production timeouts, slow down transaction processing, and potentially stall the chain.",Implementation,2024 H1/2402-invarch-srl/2402-invarch-srl.json
issue-5,Incorrect runtime weights for XCM and a set of pallets,High,Tinkernet Runtime,"In the tinkernet runtime, weights for the XCM pallet and several other pallets (e.g., orml_tokens, orml_currencies) are configured to zero. This makes their extrinsics effectively free to execute.","This misconfiguration allows an attacker to spam the network and bloat storage at no cost, and can lead to the creation of overweight blocks that cause block production timeouts.",Implementation,2024 H1/2402-invarch-srl/2402-invarch-srl.json
issue-1,Missing decode depth limit in INV4 pallet allows stack exhaustion,High,INV4 Pallet,The INV4 pallet's `vote_multisig` extrinsic decodes an encoded call without enforcing a depth limit. This allows for a deeply nested call to be processed.,"An attacker can craft a malicious call with excessive nesting, causing stack exhaustion when it is decoded. This will lead to a crash of the wasm runtime, impacting node availability.",Implementation,2024 H1/2402-invarch-srl/2402-invarch-srl.json
issue-4,Incorrect benchmarks for dependency Substrate-native pallets,Medium,Tinkernet runtime,The runtime benchmarks for several FRAME pallet dependencies are based on the generic substrate-node template instead of the actual InvArch runtime. This can lead to inaccurate weight calculations for their extrinsics.,"Incorrectly weighted extrinsics (either over or under) can be exploited by an attacker to create overweight blocks, leading to block production timeouts and reduced network performance.",Implementation,2024 H1/2402-invarch-srl/2402-invarch-srl.json
issue-3,Malicious users can bloat storage at little cost via operate_multisig,Medium,INV4 Pallet,"The `operate_multisig` extrinsic allows a user to insert a significant amount of data (metadata and a call, up to 60kb) into storage at a low cost. An attacker can repeatedly call this to fill up storage.","A malicious user can clutter storage by creating numerous multisig objects, consuming state storage and potentially degrading network performance without incurring proportional costs.",Implementation,2024 H1/2402-invarch-srl/2402-invarch-srl.json
issue-9,Incorrect weight returned by pallet_checked_inflation::on_initialize,Low,Checked Inflation Pallet,The `on_initialize` hook in the `pallet_checked_inflation` pallet returns a weight value that does not accurately reflect the number of storage reads and writes it performs. This underestimates the actual runtime resources required for its execution.,"While not directly exploitable, the wrongly estimated weight affects the remaining runtime budget of every block, which could cause block deadlines to be missed if a costly extrinsic is included.",Implementation,2024 H1/2402-invarch-srl/2402-invarch-srl.json
issue-2,Unconditional call decoding in vote_multisig is inefficient and potentially inflates weight,Informational,INV4 Pallet,"The `vote_multisig` extrinsic decodes a proposed call from storage on every vote, even before checking if the voting thresholds have been met. The decoded call is only needed if the proposal is approved for execution.","This leads to unnecessary resource consumption, as the call is decoded with every vote. For multisigs with many participants and proposals, this creates computational overhead.",Process,2024 H1/2402-invarch-srl/2402-invarch-srl.json
H-01,transfer_share_and_rewards allows for self transfer,High,rewards library,The rewards library contains the `transfer_share_and_rewards` function which allows for self-transfer. This can be exploited by a user to double their shares and rewards balance.,"A user can repeatedly call this function to infinitely increase their share and rewards balance, effectively stealing funds from the protocol.",Implementation,2024 H1/2401-acala-c4/2401-acala-c4.json
H-O2,Early user can break pool via inflation attack due to no minimum liquidity check in the incentive contract,High,incentive contract,The incentive contract does not enforce a minimum liquidity limit. This allows a user to create a pool with very little liquidity and perform an inflation attack by repeatedly depositing a small number of shares to inflate the total shares without affecting the reward calculation.,"The attack breaks the reward inflation mechanism, allowing the attacker to steal reward tokens from other users in the pool.",Design,2024 H1/2401-acala-c4/2401-acala-c4.json
H-03,transfer_share_and_rewards can be used to transfer out shares without transferring reward debt due to rounding,High,rewards library,"The calculation for `move_balance` in the `transfer_share_and_rewards` function rounds down. An attacker can construct a transaction where a small fraction of shares are transferred, causing the reward debt calculation to round to zero. The receiving account gets shares but no reward debt.","The receiving account can claim rewards that have already been accounted for by the sender's debt, allowing for rewards to be drained from the pool.",Implementation,2024 H1/2401-acala-c4/2401-acala-c4.json
M-01,"Claiming rewards while the deduction rate is != 0, allows for repeated withdrawal of redistributed rewards",Medium,rewards module,"When a user claims rewards, any applied deduction is redistributed to all participants in the pool, including the user who just claimed. This allows the user to repeatedly claim a portion of the rewards that were just deducted.",A user can claim more rewards than they are entitled to over time by repeatedly claiming their share of the redistributed deductions.,Design,2024 H1/2401-acala-c4/2401-acala-c4.json
M-02,Incentive accumulation can be sandwiched with additional shares to gain advantage over long-term depositors,Medium,incentives module,A user can deposit a large amount of shares immediately before incentive rewards are accumulated and then withdraw them immediately after. This 'sandwich' attack does not require a long-term deposit to earn rewards.,An attacker can use this strategy to obtain an unfairly high share of the rewards at the expense of long-term depositors.,Design,2024 H1/2401-acala-c4/2401-acala-c4.json
M-03,Unbond_instant removes incorrect amount of shares,Medium,earning module,The `unbond_instant` function calculates a fee but then calls the `OnUnbonded` hook with the post-fee amount. This results in the fee portion of the shares not being removed from the user's bonded amount.,"A portion of the user's shares remains in the reward system and continues to accumulate rewards, even though they should have been fully unbonded. These shares become stuck.",Implementation,2024 H1/2401-acala-c4/2401-acala-c4.json
M-04,Storage can be bloated with low liquidity positions,Medium,incentives module,"The `deposit_dex_share` function does not enforce a minimum deposit amount. This allows an attacker to create a massive number of positions with minimal liquidity (e.g., 1 wei) for a very low cost.","This can bloat the runtime storage, leading to high maintenance costs for the chain and creating a potential denial-of-service (DoS) vector.",Input Validation,2024 H1/2401-acala-c4/2401-acala-c4.json
O1,Admin is a single point of failure,Low,incentives module,The permission to update incentive-related parameters is controlled by a single `UpdateOrigin` configuration. There is no backup or alternative method to change these parameters.,"If access to the `UpdateOrigin` account is lost or compromised, it would become impossible to manage the incentive system, potentially bricking its functionality.",Access Control,2024 H1/2401-acala-c4/2401-acala-c4.json
O2,Consider adding better documentation,Informational,unspecified,Several complex functions within the codebase lack sufficient documentation. This makes it difficult for auditors and developers to understand the intended behavior and mathematical logic.,Poor documentation slows down security audits and increases the risk of incorrect integration or misuse of the protocol's functions.,Documentation,2024 H1/2401-acala-c4/2401-acala-c4.json
O3,Setters should always have equality checkers,Low,unspecified,"Setter functions, such as `set_share`, do not check if the new value is different from the current value. This leads to unnecessary state changes and triggers events even when nothing changes.",This results in wasted gas from unnecessary code execution and can introduce subtle bugs if other logic relies on the assumption that a state change implies a value change.,Implementation,2024 H1/2401-acala-c4/2401-acala-c4.json
O4,OnUpdateLoan::happened() should check for when adjustment == 0,Low,unspecified,"The `OnUpdateLoan::happened` function, which settles adjustments, does not explicitly handle cases where the adjustment is zero. The logic defaults to an attempt to remove zero shares, which is an unnecessary operation.","The lack of precise input validation leads to inefficient and slightly flawed code structure, executing unnecessary operations.",Input Validation,2024 H1/2401-acala-c4/2401-acala-c4.json
O5,Protocol does not apply deadlines when dealing with critical operations,Low,unspecified,"Critical operations such as `do_deposit_dex_share` and `do_withdraw_dex_share` lack a deadline parameter. A user's transaction could remain pending in the mempool and be executed much later at a different, potentially unfavorable, price.","Users may lose funds if their transactions are executed long after they were submitted, under different market conditions than they intended.",Design,2024 H1/2401-acala-c4/2401-acala-c4.json
O6,Fix typos,Informational,unspecified,"The codebase contains several typographical errors in code comments and documentation. For example, 'avalailable' instead of 'available'.","Typos reduce code clarity and professionalism, and can occasionally lead to misunderstandings of intent.",Documentation,2024 H1/2401-acala-c4/2401-acala-c4.json
O7,Consider using BST instead,Informational,unspecified,The report notes that reward information is stored in a B-Tree map. It suggests that a balanced binary search tree (BST) could be a more performant data structure for this use case.,"The current data structure choice may not be the most optimal, leading to slightly higher computational costs for searching and accessing reward data.",Design,2024 H1/2401-acala-c4/2401-acala-c4.json
O8,Consider not switching off important clippy protection methods,Informational,unspecified,"The project configuration disables several useful lints from Clippy, Rust's static analysis tool, such as `clippy::unused_unit`. These lints are designed to catch common mistakes and improve code quality.","Disabling protective lints can allow flawed or poorly structured code to be committed, potentially hiding underlying bugs or design issues.",Process,2024 H1/2401-acala-c4/2401-acala-c4.json
S2-47,Incorrect gas weighting may stall block production,Medium,runtime/moonbeam,"The gas cost for the EVM's extcodesize opcode is converted to a static Substrate weight. An attacker can call extcodesize on a non-existent address, which forces two computationally expensive storage reads. This circumvents protections that normally prevent large contract deployments from having incorrectly low gas-to-weight calculations.","If exploited over XCM, the forced execution of these overweight operations could lead to blocks that are too large, resulting in a denial-of-service condition for the Moonbeam network.",Implementation,2024 H1/2401-moonbeam-srl/2401-moonbeam-srl-audit-report.json
S2-51,Incorrect configuration of runtime weights,Medium,Runtime,"Multiple pallets (including cumulus-pallet-parachain-system, cumulus-pallet-dmp-queue, and pallet-message-queue) in the Moonbeam, Moonbase, and Moonriver runtimes were incorrectly configured to use default, non-benchmarked Substrate weights. This means the declared cost of operations did not reflect their actual computational cost.","Using non-benchmarked weights can lead to the creation of overweight extrinsics. This may cause blocks to be rejected by the relay-chain during validation, leading to network availability issues.",Configuration,2024 H1/2401-moonbeam-srl/2401-moonbeam-srl-audit-report.json
M-01,Limited availability of balance_of(...) method,Medium,Phat Contract Runtime,"The `balance_of` method is incorrectly restricted to be callable only by the system contract due to an `ensure_system` check. According to the provided documentation, this method should be available to any contract.","User contracts relying on the `balance_of` method as per the documentation will fail, as they do not have the required system-level origin to pass the check.",Access Control,2024 H1/2401-phala-c4/2401-phala-c4.json
M-02,An attacker can bloat the Pink runtime storage with zero costs,Medium,Pink runtime,"The `ExistentialDeposit` constant in the Pink runtime is set to 1, an extremely low value. This allows an attacker to create a vast number of dust accounts for a negligible cost, leading to storage bloat.",A storage bloat attack increases storage and processing costs for all users on the network and can degrade overall performance.,Configuration,2024 H1/2401-phala-c4/2401-phala-c4.json
M-03,A cache that times out can be recovered,Medium,LocalCache,"The `LocalCache#set_expire` function allows resetting the expiration time for a key without checking if the key has already expired. This can lead to the 'reactivation' of an expired key, causing stale data to be treated as valid.","An attacker can force the system to reuse stale data by reactivating expired cache entries, potentially leading to data inconsistency, incorrect logic execution, or price manipulation if the cache is used for off-chain data like price feeds.",Implementation,2024 H1/2401-phala-c4/2401-phala-c4.json
M-04,An attacker can crash the cluster system by sending an HTTP request with a huge timeout,Medium,Phat Contract Runtime,"In the `batch_http_request` function, a fixed value of 200ms is added to the user-supplied timeout. If a user provides a timeout value close to the maximum for a u64 integer, this addition causes an arithmetic overflow, leading to a panic.","Any user can intentionally send a crafted request with a large timeout value, causing the worker process to crash. This can be used to execute a Denial of Service (DoS) attack against the entire cluster at no cost to the attacker.",Input Validation,2024 H1/2401-phala-c4/2401-phala-c4.json
01,No point in using regular http request over batchhttperequest,Informational,Phat Contract Runtime,"The `batchhttprequest` function is not restricted to handling multiple requests and can be used for a single request. It offers a longer timeout bound, making it strictly superior to the singular `httprequest` function.",The presence of a seemingly inferior function (`httprequest`) can cause confusion for developers and lead to less robust implementation choices.,Design,2024 H1/2401-phala-c4/2401-phala-c4.json
02,CallinCommand is misleading and should be renamed callinTransaction for clarity,Informational,Phat Contract Runtime,The name `CallinCommand` is ambiguous. Renaming it to `callinTransaction` would more clearly reflect its purpose and improve code readability.,Misleading names can lead to developer confusion and potential misuse of the function.,Documentation,2024 H1/2401-phala-c4/2401-phala-c4.json
03,is_running_in_command function is missing or misnamed in the code,Informational,Phat Contract Runtime,The function `is_running_in_command` mentioned in documentation appears to be implemented as `is_it_in_transaction` in the code. This discrepancy should be corrected.,Inconsistency between documentation and code can hinder development and maintenance.,Documentation,2024 H1/2401-phala-c4/2401-phala-c4.json
04,Functions that are not supported in transaction mode should revert not send empty arrays,Informational,Phat Contract Runtime,"Functions that are not supported in a specific transaction mode return empty arrays instead of reverting. This can be misleading to callers who might interpret an empty array as a valid, empty result set.",Returning empty arrays instead of reverting on unsupported operations can lead to silent failures and bad developer experience.,Design,2024 H1/2401-phala-c4/2401-phala-c4.json
05,Masking deposit calculation can lead to unexpected results in certain circumstances,Low,Phat Contract Runtime,"The `mask_deposit` function uses complex bit math to mitigate side-channel attacks. However, the invariant that the masked deposit must be greater than or equal to the original deposit can be broken with a specific `deposit_per_byte` value.","If a malicious cluster creator sets a problematic `deposit_per_byte` value, it could open up the side-channel attack that the masking function is intended to prevent.",Implementation,2024 H1/2401-phala-c4/2401-phala-c4.json
06,is_in_transaction return value can be misleading,Informational,Phat Contract Runtime,"The `is_in_transaction` function returns true when a call is in estimating mode, because estimation mode is treated the same as a transaction. This is misleading, as no transaction is actually being executed.","The misleading return value could cause developers to make incorrect assumptions about the execution context, leading to logic errors in contracts.",Implementation,2024 H1/2401-phala-c4/2401-phala-c4.json
07,No code size limit check in function put_sidevm_code,Informational,Phat Contract Runtime,"The function `put_sidevm_code` does not perform a size limit check on the code being uploaded. While an on-chain limit exists, adding a check in this function would be a good practice.","Lack of an explicit check could lead to unexpected behavior if the on-chain limit changes or is removed, and it represents a missed defense-in-depth opportunity.",Implementation,2024 H1/2401-phala-c4/2401-phala-c4.json
missing-benchmarking-for-the-lockdrop-precompile-dispatch--precompiles-dispatch-lockdrop--informational,Missing benchmarking for the lockdrop precompile dispatch,Informational,precompiles/dispatch-lockdrop,"The precompile dispatch-lockdrop has an un-benchmarked weight_to_gas estimation. A static ref_time is used for weight calculation, which can lead to an underestimation of the weights and does not reflect the actual runtime environment.",An attacker may be able to spam the chain and conduct denial of service attacks cheaply in comparison to the actual transaction cost.,Implementation,2024 H1/2403-astar-srl/2403-astar-sr.json
unbounded-call-length-limit-in-lockdrop-dispatch-call--precompiles-dispatch-lockdrop--low,Unbounded call length limit in lockdrop dispatch call,Low,precompiles/dispatch-lockdrop,"The precompile dispatch call uses the `UnboundedBytes` type without any length validation for the call object parameter. An unbounded call with a large `call_length` can be moved into a vector before decoding, creating a potential for heap overflow.","An attacker can create multiple nested calls to bloat the call_length, which can cause a heap overflow and lead to a denial of service.",Input Validation,2024 H1/2403-astar-srl/2403-astar-sr.json
S3-55,Constructing smart contract can bypass precompile address bounding,High,/precompiles/src/precompile_set.rs,"The access control check intended to prevent smart contracts from calling certain precompiles can be bypassed. The check incorrectly assumes that an account with a code length of zero must be an externally owned account, but this condition is also true for smart contracts that are under construction.","Attackers can bypass the filter and call precompiles that should be restricted, potentially leading to complex logic-based attacks. This is especially risky for third-party developers who rely on this security assumption.",Access Control,2025 Q2/frontier-srlabs-2505/frontier-srlabs-2505.json
S2-59,Missing check_inherent for note_min_gas_price_target inflates gas price,Medium,/frame/dynamic-fee/src/lib.rs,"The inherent extrinsic `note_min_gas_price_target` lacks a `check_inherent` function, which is necessary to allow network nodes to verify the data submitted by the block producer. This omission allows a block producer to set the minimum gas price target without any validation from the network.","A malicious block producer could repeatedly set the gas price to its maximum allowed value, causing transaction fees to inflate continuously. This would render contract execution prohibitively expensive, leading to a denial-of-service.",Implementation,2025 Q2/frontier-srlabs-2505/frontier-srlabs-2505.json
S2-58,Silent failure in Curve25519 arithmetic precompiles with malformed points,Medium,/frame/evm/precompile/curve25519/src/lib.rs,"The Curve25519 arithmetic precompiles do not correctly handle invalid Ristretto point representations. Instead of returning an error, they silently treat malformed inputs as the cryptographic identity element, which can lead to incorrect results in cryptographic operations.","This flaw could be abused to bypass cryptographic checks, such as compromising key exchanges or enabling signature forgery in multi-signature schemes by submitting invalid points that are incorrectly counted towards the threshold.",Cryptography,2025 Q2/frontier-srlabs-2505/frontier-srlabs-2505.json
S2-57,Various underpriced precompiles can lead to DoS attack,Medium,/frame/evm/precompile/*,"Several precompiles, notably `Curve25519Add`, have a gas cost that is significantly lower than their actual computational cost. Benchmarks show that this precompile requires about ten times more CPU time than another precompile with the same gas cost, indicating improper benchmarking.","An attacker could exploit this by crafting transactions that call the underpriced precompiles, consuming excessive CPU resources while paying minimal fees. This could slow down or halt block production, resulting in a network denial-of-service.",Implementation,2025 Q2/frontier-srlabs-2505/frontier-srlabs-2505.json
S0-56,FeeMultiplierUpdate not set to a TargetedFeeAdjustment type,Informational,/template/runtime/src/lib.rs,"The provided runtime template for Frontier developers configures network fees to use a constant multiplier. This means that transaction fees do not automatically adjust to network congestion, as the fee calculation does not account for current network usage.","Since fees do not reflect network congestion, an attacker could censor transactions by flooding the network and paying only the base fee. This could cause a denial-of-service against zero-tip transactions for an extended period.",Configuration,2025 Q2/frontier-srlabs-2505/frontier-srlabs-2505.json
missing-validation-for-point-at-infinity--micro-sr25519--medium,Missing validation for point at infinity,Medium,micro-sr25519,"The audit identified that there is no validation to ensure the public key is not the point at infinity. Because scalar multiplication by zero yields the identity, an attacker could use the identity point as a public key to pass signature verification without possessing a corresponding secret key.","This vulnerability could allow an attacker to forge signatures that would be accepted as valid, potentially leading to unauthorized actions or transaction spoofing.",Implementation,2025 Q2/microsr25519-oak-2504/microsr25519-oak-2504.json
ambiguous-transcript-construction-due-to-empty-label--micro-sr25519--medium,Ambiguous transcript construction due to empty label,Medium,micro-sr25519,"The `label` method within `SigningContext` uses an empty string, which is problematic for the Merlin transcript system it employs. In Merlin, labels are essential for domain separation and context binding to prevent state collisions.","Using an empty label can lead to ambiguous or overlapping transcript states, which undermines the uniqueness guarantees of cryptographic signatures and could allow for potential forgery.",Cryptography,2025 Q2/microsr25519-oak-2504/microsr25519-oak-2504.json
missing-flag-to-enable-improved-transcription-ordering-for-vrf--micro-sr25519--medium,Missing flag to enable improved transcription ordering for VRF,Medium,micro-sr25519,"The library commits the public key to the transcript after the nonce, following a pattern compatible with Kusama but diverging from a more secure ordering that mitigates certain attacks. The report notes this could be exploited by a malicious actor to undermine the VRF's security assumptions.",This design choice could expose the Verifiable Random Function (VRF) to attacks that exploit discrepancies between public and secret key alignments in environments requiring stronger cryptographic assurances.,Cryptography,2025 Q2/microsr25519-oak-2504/microsr25519-oak-2504.json
incomplete-signature-format-validation-may-allow-non-canonical-inputs--micro-sr25519--medium,Incomplete signature format validation may allow non-canonical inputs,Medium,micro-sr25519,"The signature verification logic does not fully enforce the sr25519 specification. While it correctly checks for the Schnorrkel marker bit in the final signature byte, it fails to validate that the remaining bits are cleared, which is a requirement for canonical signature encoding.","Acceptance of non-canonical signatures can undermine the strict format guarantees that cryptographic protocols depend on, potentially causing interoperability failures or security vulnerabilities.",Implementation,2025 Q2/microsr25519-oak-2504/microsr25519-oak-2504.json
potential-timing-side-channel-in-scalar-arithmetic-operations--micro-sr25519--medium,Potential timing side-channel in scalar arithmetic operations,Medium,micro-sr25519,Scalar arithmetic operations within the codebase may be susceptible to timing side-channel attacks. This is due to the variable-time behavior of the underlying bigInt implementation in the JavaScript environment.,"Although modern JavaScript engines provide some mitigation, a sophisticated attacker in an adversarial setting could potentially exploit these timing variations to extract secret key information.",Cryptography,2025 Q2/microsr25519-oak-2504/microsr25519-oak-2504.json
insufficient-input-validation--micro-sr25519--medium,Insufficient input validation,Medium,micro-sr25519,"The `secretFromSeed` and `getSharedSecret` functions do not perform comprehensive input validation. For instance, they do not check for zeroed arrays or other structurally invalid inputs, which can result in incorrect computations.","Lack of robust input validation could lead to incorrect cryptographic outputs or unexpected behavior, weakening the overall security guarantees provided by the library.",Input Validation,2025 Q2/microsr25519-oak-2504/microsr25519-oak-2504.json
the-chain-code-is-generated-but-not-returned-to-the-caller--micro-sr25519--medium,The chain code is generated but not returned to the caller,Medium,micro-sr25519,"During execution, a chain code is calculated within a `SigningContext` but is subsequently discarded instead of being returned to the calling function. This behavior is inefficient and deviates from the design of reference implementations like Schnorrkel in Rust.","This implementation detail makes it impossible for callers to leverage the dynamically generated chain code for further key derivation or processing, limiting the library's utility for HDKD (Hierarchical Deterministic Key Derivation) use cases.",Implementation,2025 Q2/microsr25519-oak-2504/microsr25519-oak-2504.json
insecure-rng-injection-in-signing-and-vrf-functions--micro-sr25519--informational,Insecure RNG injection in signing and VRF functions,Informational,micro-sr25519,"The signing and VRF functions in the library permit an overridable `rng` parameter. This design introduces a security risk if the user supplies a weak, deterministic, or replayable Random Number Generator (RNG), as it could make nonce values predictable.","If a predictable RNG is used, a malicious actor could potentially derive private keys, compromising the security of the cryptographic operations.",Cryptography,2025 Q2/microsr25519-oak-2504/microsr25519-oak-2504.json
lack-of-input-size-restrictions-may-allow-denial-of-service-attacks--micro-sr25519--informational,Lack of input size restrictions may allow denial of service attacks,Informational,micro-sr25519,"The library does not enforce any maximum length constraints on several input parameters, including `message`, `context`, and `extra`. The library's internal byte-by-byte processing could lead to severe performance degradation if excessively large inputs are provided.","In a backend service context, an attacker could exploit this by sending very large inputs, leading to high resource consumption and a potential denial-of-service (DoS) attack.",Input Validation,2025 Q2/microsr25519-oak-2504/microsr25519-oak-2504.json
misleading-error-message-in-vrf-output-point-identity-check--micro-sr25519--informational,Misleading error message in VRF output point identity check,Informational,micro-sr25519,"The VRF verification function includes a check to detect if the output is the identity (zero) point. While the check is implemented correctly, the associated error message inaccurately states that the check applies to the public key, not the output point.","This misrepresentation in the error message can cause confusion for developers, hindering debugging efforts and potentially leading to misinterpretation of security assessments.",Implementation,2025 Q2/microsr25519-oak-2504/microsr25519-oak-2504.json
presence-of-todos-and-pending-items--micro-sr25519--informational,Presence of TODOs and pending items,Informational,micro-sr25519,"The audit of the codebase revealed the presence of unresolved TODO comments and other pending items. These markers indicate segments of the code that are incomplete, unverified, or require further attention.","Leaving such items in production code can represent a maintenance and security risk, as they may correspond to unfinished features, missing error handling, or areas that have not undergone full security scrutiny.",Documentation,2025 Q2/microsr25519-oak-2504/microsr25519-oak-2504.json
secret-keys-encoded-as-ed25519-bytes--micro-sr25519--informational,"micro-sr25519 secret keys are encoded as ed25519 bytes, which is different than schnorrkel default encoding",Informational,micro-sr25519,Differential fuzz testing revealed that the TypeScript functions in `micro-sr25519` encode secret keys using the ed25519 byte format. This differs from the default internal format used by the Rust `schnorrkel` reference implementation.,"This encoding difference can cause significant interoperability issues if keys are generated in one implementation and used in the other without explicit conversion, leading to signature validation failures.",Implementation,2025 Q2/microsr25519-oak-2504/microsr25519-oak-2504.json